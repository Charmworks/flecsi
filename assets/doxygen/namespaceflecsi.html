<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>flecsi: flecsi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="small-flecsi.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">flecsi
   &#160;<span id="projectnumber">0.0-1532-gec32c03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">flecsi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>user includes  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1as__sequence__.html">as_sequence_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1as__sequence___3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">as_sequence_&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1bitfield____.html">bitfield__</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflecsi_1_1bitfield____.html" title="bitfield__ provides... ">bitfield__</a> provides...  <a href="classflecsi_1_1bitfield____.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1check__sig.html">check_sig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structflecsi_1_1check__sig.html" title="check_sig provides... ">check_sig</a> provides...  <a href="structflecsi_1_1check__sig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1check__sig_3_01T_00_01rVal_07_5_08_07Args_8_8_8_08_4.html">check_sig&lt; T, rVal(*)(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1data__handle__t.html">data_handle_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1default__user__meta__data__t.html">default_user_meta_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> type provides a general base for defining contiguous array types that have a specific dimension. Please look at the <a class="el" href="classpoint.html">point</a> and vector types for an example of its use.  <a href="classflecsi_1_1dimensioned__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1Factory__.html">Factory_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflecsi_1_1Factory__.html" title="Factory_ provides a generic object factory class. ">Factory_</a> provides a generic object factory class.  <a href="classflecsi_1_1Factory__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1function__traits____.html">function_traits__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1function__traits_____3_01R_07As_8_8_8_08_4.html">function_traits__&lt; R(As...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1generic__tuple__t.html">generic_tuple_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1id__.html">id_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1index__space__t.html">index_space_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1io__base__t.html">io_base_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflecsi_1_1io__base__t.html" title="io_base_t provides a base class using the object factory with pure virtual functions for read and wri...">io_base_t</a> provides a base class using the object factory with pure virtual functions for read and write.  <a href="classflecsi_1_1io__base__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1io__exodus__t.html">io_exodus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structflecsi_1_1io__exodus__t.html" title="io_exodus_t provides a derived type of io_base.h and registrations of the exodus file extensions...">io_exodus_t</a> provides a derived type of <a class="el" href="io__base_8h.html">io_base.h</a> and registrations of the exodus file extensions.  <a href="structflecsi_1_1io__exodus__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1is__tuple_3_01std_1_1tuple_3_01T_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator provides...  <a href="classflecsi_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1make__filtered__sequence__.html">make_filtered_sequence_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1make__filtered__sequence___3_01P_00_01T_00_01std_1_1index__sequence_3_01Is_8_8_8_01_4_01_4.html">make_filtered_sequence_&lt; P, T, std::index_sequence&lt; Is... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1make__filtered__sequence__index__.html">make_filtered_sequence_index_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1make__filtered__sequence__index___3_01P_00_01T_00_01std_1_1index__sequence_3_01Is_8_8_8_01_4_01_4.html">make_filtered_sequence_index_&lt; P, T, std::index_sequence&lt; Is... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1tuple__wrapper__.html">tuple_wrapper_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1unique__id__t.html">unique_id_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate unique ids.  <a href="structflecsi_1_1unique__id__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1virtual__semaphore.html">virtual_semaphore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a88163bc6541084dd3d424a99102bac7b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88163bc6541084dd3d424a99102bac7b"></a>
template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:a88163bc6541084dd3d424a99102bac7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>point</b> = <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, 1 &gt;</td></tr>
<tr class="separator:a88163bc6541084dd3d424a99102bac7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7262366b3674b2e480072c2e9c0d8fc6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7262366b3674b2e480072c2e9c0d8fc6"></a>
template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:a7262366b3674b2e480072c2e9c0d8fc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>space_vector</b> = <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, 2 &gt;</td></tr>
<tr class="separator:a7262366b3674b2e480072c2e9c0d8fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de73bf6840f69aaede970c8eeca407f"><td class="memTemplParams" colspan="2">template&lt;typename mesh_t &gt; </td></tr>
<tr class="memitem:a2de73bf6840f69aaede970c8eeca407f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a2de73bf6840f69aaede970c8eeca407f">io_factory_t</a> = <a class="el" href="classflecsi_1_1Factory__.html">flecsi::Factory_</a>&lt; <a class="el" href="classflecsi_1_1io__base__t.html">io_base_t</a>&lt; <a class="el" href="structmesh__t.html">mesh_t</a> &gt;, std::string &gt;</td></tr>
<tr class="memdesc:a2de73bf6840f69aaede970c8eeca407f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory type definition for io. <a class="el" href="classflecsi_1_1Factory__.html" title="Factory_ provides a generic object factory class. ">flecsi::Factory_</a> templated on <a class="el" href="classflecsi_1_1io__base__t.html" title="io_base_t provides a base class using the object factory with pure virtual functions for read and wri...">io_base_t</a> and string. Used for registering a file extenstion with a factory.  <a href="#a2de73bf6840f69aaede970c8eeca407f">More...</a><br /></td></tr>
<tr class="separator:a2de73bf6840f69aaede970c8eeca407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6550f0043ffb89118f0c7e93e94cbafe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6550f0043ffb89118f0c7e93e94cbafe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bitfield_t</b> = <a class="el" href="classflecsi_1_1bitfield____.html">bitfield__</a>&lt; uint32_t &gt;</td></tr>
<tr class="separator:a6550f0043ffb89118f0c7e93e94cbafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e21d44c7ac4e80959e26a22bfc769d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1e21d44c7ac4e80959e26a22bfc769d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>id_t</b> = <a class="el" href="classflecsi_1_1id__.html">id_</a>&lt; FLECSI_ID_PBITS, FLECSI_ID_EBITS, FLECSI_ID_FBITS, FLECSI_ID_GBITS &gt;</td></tr>
<tr class="separator:ae1e21d44c7ac4e80959e26a22bfc769d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2bc59194346f25945d1740efc56710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a2bc59194346f25945d1740efc56710"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>counter_t</b> = FLECSI_COUNTER_TYPE</td></tr>
<tr class="separator:a1a2bc59194346f25945d1740efc56710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56223955f1ee01a4fff258522ad80dcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56223955f1ee01a4fff258522ad80dcf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>local_id_t</b> = __uint128_t</td></tr>
<tr class="separator:a56223955f1ee01a4fff258522ad80dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a225a4da1ec871f797f4e66e086cb471c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a225a4da1ec871f797f4e66e086cb471c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>axis</b> : size_t { <b>x</b> = 0, 
<b>y</b> = 1, 
<b>z</b> = 2
 }</td></tr>
<tr class="separator:a225a4da1ec871f797f4e66e086cb471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aebccd0a69da553e1696fc673c0ed65eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aebccd0a69da553e1696fc673c0ed65eb"></a>
template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:aebccd0a69da553e1696fc673c0ed65eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T val, const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;p)</td></tr>
<tr class="separator:aebccd0a69da553e1696fc673c0ed65eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6425bc674c81543e3b5f0de15f0b9f"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:a3d6425bc674c81543e3b5f0de15f0b9f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a3d6425bc674c81543e3b5f0de15f0b9f">distance</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;b)</td></tr>
<tr class="separator:a3d6425bc674c81543e3b5f0de15f0b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52049000b478c401bd80ab5424965c78"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:a52049000b478c401bd80ab5424965c78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a52049000b478c401bd80ab5424965c78">midpoint</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;b)</td></tr>
<tr class="separator:a52049000b478c401bd80ab5424965c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f027dc30c226754e367fd96e47be099"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class LIST, typename T , size_t D&gt; </td></tr>
<tr class="memitem:a9f027dc30c226754e367fd96e47be099"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a9f027dc30c226754e367fd96e47be099">centroid</a> (const LIST&lt; <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt;&gt; &amp;vert_list)</td></tr>
<tr class="separator:a9f027dc30c226754e367fd96e47be099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355ec64f955df3c16aadfd0045d5d597"><td class="memTemplParams" colspan="2"><a class="anchor" id="a355ec64f955df3c16aadfd0045d5d597"></a>
template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:a355ec64f955df3c16aadfd0045d5d597"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>centroid</b> (std::initializer_list&lt; <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt;&gt; vert_list)</td></tr>
<tr class="separator:a355ec64f955df3c16aadfd0045d5d597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50ffae3f2ba9b3a3d548cd0a4910998"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:ad50ffae3f2ba9b3a3d548cd0a4910998"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ad50ffae3f2ba9b3a3d548cd0a4910998">point_to_vector</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;p)</td></tr>
<tr class="memdesc:ad50ffae3f2ba9b3a3d548cd0a4910998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of a point type to a <a class="el" href="classspace__vector.html" title="space_vector defines an interface for storing and manipulating space_vector data associated with a ge...">space_vector</a> type. Because point has template parameter TS = 1, and <a class="el" href="classspace__vector.html" title="space_vector defines an interface for storing and manipulating space_vector data associated with a ge...">space_vector</a> has template parameter TS = 2, the usual copy/assignment constructors don't work as one would hope. There is probably a better way to do this.  <a href="#ad50ffae3f2ba9b3a3d548cd0a4910998">More...</a><br /></td></tr>
<tr class="separator:ad50ffae3f2ba9b3a3d548cd0a4910998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a2738b3592492e183566d68cb1a612"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:ae0a2738b3592492e183566d68cb1a612"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ae0a2738b3592492e183566d68cb1a612">operator*</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;v, const T s)</td></tr>
<tr class="separator:ae0a2738b3592492e183566d68cb1a612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4102871ead95b156dc6ba36f7997dcd3"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:a4102871ead95b156dc6ba36f7997dcd3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a4102871ead95b156dc6ba36f7997dcd3">dot</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;b)</td></tr>
<tr class="separator:a4102871ead95b156dc6ba36f7997dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf440381d22446d7a23fc234b3f5dd7b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D&gt; </td></tr>
<tr class="memitem:acf440381d22446d7a23fc234b3f5dd7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#acf440381d22446d7a23fc234b3f5dd7b">magnitude</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;a)</td></tr>
<tr class="separator:acf440381d22446d7a23fc234b3f5dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00aa0fd0011d23e53e2cd5d5c06b638"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae00aa0fd0011d23e53e2cd5d5c06b638"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ae00aa0fd0011d23e53e2cd5d5c06b638">cross_magnitude</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 1 &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 1 &gt; &amp;b)</td></tr>
<tr class="separator:ae00aa0fd0011d23e53e2cd5d5c06b638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c33ed916021542824dcd39b641043e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c33ed916021542824dcd39b641043e1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a8c33ed916021542824dcd39b641043e1">cross_magnitude</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 2 &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 2 &gt; &amp;b)</td></tr>
<tr class="separator:a8c33ed916021542824dcd39b641043e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e86d3d804972fbb935e736f8ad5ee68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e86d3d804972fbb935e736f8ad5ee68"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a8e86d3d804972fbb935e736f8ad5ee68">cross_magnitude</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;b)</td></tr>
<tr class="separator:a8e86d3d804972fbb935e736f8ad5ee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7c372686a27b05898a4808c648149c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a7c372686a27b05898a4808c648149c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a7a7c372686a27b05898a4808c648149c">normal</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, 2 &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, 2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a7a7c372686a27b05898a4808c648149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">for a vector xi + yj the normal vector is -yi + xj. given points a and b we use x = b[0] - a[0] and y = b[1] - a[1]  <a href="#a7a7c372686a27b05898a4808c648149c">More...</a><br /></td></tr>
<tr class="separator:a7a7c372686a27b05898a4808c648149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21406e33994f7c8b1ded3e8c556b38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d21406e33994f7c8b1ded3e8c556b38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a4d21406e33994f7c8b1ded3e8c556b38">normal</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;a, const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;b)</td></tr>
<tr class="separator:a4d21406e33994f7c8b1ded3e8c556b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f499a58b7832887ba6f2b4c112c7bfb"><td class="memTemplParams" colspan="2">template&lt;typename mesh_t &gt; </td></tr>
<tr class="memitem:a4f499a58b7832887ba6f2b4c112c7bfb"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a4f499a58b7832887ba6f2b4c112c7bfb">read_mesh</a> (const std::string &amp;name, <a class="el" href="structmesh__t.html">mesh_t</a> &amp;m)</td></tr>
<tr class="memdesc:a4f499a58b7832887ba6f2b4c112c7bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic mesh reader that calls the correct method based on the suffix.  <a href="#a4f499a58b7832887ba6f2b4c112c7bfb">More...</a><br /></td></tr>
<tr class="separator:a4f499a58b7832887ba6f2b4c112c7bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab161a9166ab366149e43aa6324aa50d"><td class="memTemplParams" colspan="2">template&lt;typename mesh_t &gt; </td></tr>
<tr class="memitem:aab161a9166ab366149e43aa6324aa50d"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#aab161a9166ab366149e43aa6324aa50d">write_mesh</a> (const std::string &amp;name, <a class="el" href="structmesh__t.html">mesh_t</a> &amp;m)</td></tr>
<tr class="memdesc:aab161a9166ab366149e43aa6324aa50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic mesh writer that calls the correct method based on the suffix.  <a href="#aab161a9166ab366149e43aa6324aa50d">More...</a><br /></td></tr>
<tr class="separator:aab161a9166ab366149e43aa6324aa50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c10a5cdd3d14eddc69fdfe09f2af1f3"><td class="memTemplParams" colspan="2">template&lt;typename mesh_t &gt; </td></tr>
<tr class="memitem:a6c10a5cdd3d14eddc69fdfe09f2af1f3"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a6c10a5cdd3d14eddc69fdfe09f2af1f3">write_mesh</a> (const std::string &amp;name, <a class="el" href="structmesh__t.html">mesh_t</a> &amp;m, bool binary)</td></tr>
<tr class="memdesc:a6c10a5cdd3d14eddc69fdfe09f2af1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic mesh writer that calls the correct method based on the suffix.  <a href="#a6c10a5cdd3d14eddc69fdfe09f2af1f3">More...</a><br /></td></tr>
<tr class="separator:a6c10a5cdd3d14eddc69fdfe09f2af1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b055e9f2fd8cb9c8556361c1fc2c2d"><td class="memTemplParams" colspan="2">template&lt;typename mesh_t &gt; </td></tr>
<tr class="memitem:a17b055e9f2fd8cb9c8556361c1fc2c2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1io__base__t.html">io_base_t</a>&lt; <a class="el" href="structmesh__t.html">mesh_t</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a17b055e9f2fd8cb9c8556361c1fc2c2d">create_io_exodus</a> ()</td></tr>
<tr class="memdesc:a17b055e9f2fd8cb9c8556361c1fc2c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="structflecsi_1_1io__exodus__t.html" title="io_exodus_t provides a derived type of io_base.h and registrations of the exodus file extensions...">io_exodus_t</a> and return a pointer to the base class.  <a href="#a17b055e9f2fd8cb9c8556361c1fc2c2d">More...</a><br /></td></tr>
<tr class="separator:a17b055e9f2fd8cb9c8556361c1fc2c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223802c361553dac199aa94471a3677b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a223802c361553dac199aa94471a3677b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (io, readwrite)</td></tr>
<tr class="separator:a223802c361553dac199aa94471a3677b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071d702a727d11d896b52f6013625e15"><td class="memTemplParams" colspan="2"><a class="anchor" id="a071d702a727d11d896b52f6013625e15"></a>
template&lt;class rT , class... Args&gt; </td></tr>
<tr class="memitem:a071d702a727d11d896b52f6013625e15"><td class="memTemplItemLeft" align="right" valign="top">rT&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DummyFoo</b> (Args...args)</td></tr>
<tr class="separator:a071d702a727d11d896b52f6013625e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798cb7384ab814540c931631b64b40c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a798cb7384ab814540c931631b64b40c7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (const char *name)</td></tr>
<tr class="separator:a798cb7384ab814540c931631b64b40c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf22be81cbd756cb01d2ef16088f075f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaf22be81cbd756cb01d2ef16088f075f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf22be81cbd756cb01d2ef16088f075f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#aaf22be81cbd756cb01d2ef16088f075f">square</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aaf22be81cbd756cb01d2ef16088f075f"><td class="mdescLeft">&#160;</td><td class="mdescRight">P.O.D. <br /></td></tr>
<tr class="separator:aaf22be81cbd756cb01d2ef16088f075f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1979359b1757ce945549f299edb88d73"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1979359b1757ce945549f299edb88d73"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1979359b1757ce945549f299edb88d73"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type</b> ()</td></tr>
<tr class="separator:a1979359b1757ce945549f299edb88d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1a4b8fad235d6c6bec7af98c76bbcc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9d1a4b8fad235d6c6bec7af98c76bbcc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d1a4b8fad235d6c6bec7af98c76bbcc"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a9d1a4b8fad235d6c6bec7af98c76bbcc">unique_name</a> (const T *t)</td></tr>
<tr class="memdesc:a9d1a4b8fad235d6c6bec7af98c76bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique name from the type, address, and unique id. <br /></td></tr>
<tr class="separator:a9d1a4b8fad235d6c6bec7af98c76bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90571855bcc6e564029d77944a2d8da"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D, size_t TS&gt; </td></tr>
<tr class="memitem:ac90571855bcc6e564029d77944a2d8da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ac90571855bcc6e564029d77944a2d8da">operator+</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;lhs, const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac90571855bcc6e564029d77944a2d8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator involving two dimensioned_arrays.  <a href="#ac90571855bcc6e564029d77944a2d8da">More...</a><br /></td></tr>
<tr class="separator:ac90571855bcc6e564029d77944a2d8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26f3bc2962eedb1bc41565d2769b5d0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D, size_t TS&gt; </td></tr>
<tr class="memitem:af26f3bc2962eedb1bc41565d2769b5d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#af26f3bc2962eedb1bc41565d2769b5d0">operator-</a> (const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;lhs, const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af26f3bc2962eedb1bc41565d2769b5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator involving two dimensioned_arrays.  <a href="#af26f3bc2962eedb1bc41565d2769b5d0">More...</a><br /></td></tr>
<tr class="separator:af26f3bc2962eedb1bc41565d2769b5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e11ad0e04d2d90c6467c284c70ecf8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t D, size_t TS&gt; </td></tr>
<tr class="memitem:a97e11ad0e04d2d90c6467c284c70ecf8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a97e11ad0e04d2d90c6467c284c70ecf8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;a)</td></tr>
<tr class="memdesc:a97e11ad0e04d2d90c6467c284c70ecf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>.  <a href="#a97e11ad0e04d2d90c6467c284c70ecf8">More...</a><br /></td></tr>
<tr class="separator:a97e11ad0e04d2d90c6467c284c70ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f0c044f5800a9970631a48e2429eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a092f0c044f5800a9970631a48e2429eb"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a092f0c044f5800a9970631a48e2429eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hash__</b> (U &amp;&amp;str, T h, std::size_t i, std::size_t n)</td></tr>
<tr class="separator:a092f0c044f5800a9970631a48e2429eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74ec8cb6d45298109175c503a009d36"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae74ec8cb6d45298109175c503a009d36"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae74ec8cb6d45298109175c503a009d36"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ae74ec8cb6d45298109175c503a009d36">hash</a> (U &amp;&amp;str, std::size_t n)</td></tr>
<tr class="memdesc:ae74ec8cb6d45298109175c503a009d36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classconst__string.html" title="const_string provides compile-time string constants and hashing... ">const_string</a> provides compile-time string constants and hashing... <br /></td></tr>
<tr class="separator:ae74ec8cb6d45298109175c503a009d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb3db53c7cefe4130630c7fe197032"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadbb3db53c7cefe4130630c7fe197032"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;ostr, local_id_t x)</td></tr>
<tr class="separator:aadbb3db53c7cefe4130630c7fe197032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad632478a9ad09abb8d2e03ae17f07df5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t... Is&gt; </td></tr>
<tr class="memitem:ad632478a9ad09abb8d2e03ae17f07df5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ad632478a9ad09abb8d2e03ae17f07df5">filter_impl_</a> (const T &amp;t, std::index_sequence&lt; Is... &gt;) -&gt; std::tuple&lt; std::tuple_element_t&lt; Is, T &gt;... &gt;</td></tr>
<tr class="separator:ad632478a9ad09abb8d2e03ae17f07df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ef7cabc62cd0e998134cacb38aab3b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename P, typename T &gt; </td></tr>
<tr class="memitem:ac4ef7cabc62cd0e998134cacb38aab3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#ac4ef7cabc62cd0e998134cacb38aab3b">tuple_filter_</a> (const T &amp;t)</td></tr>
<tr class="separator:ac4ef7cabc62cd0e998134cacb38aab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81331ddedd4417f7624a9fff1f2ebc52"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename P, typename T &gt; </td></tr>
<tr class="memitem:a81331ddedd4417f7624a9fff1f2ebc52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflecsi.html#a81331ddedd4417f7624a9fff1f2ebc52">tuple_filter_index_</a> (const T &amp;t)</td></tr>
<tr class="separator:a81331ddedd4417f7624a9fff1f2ebc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd7cf162e9f83adb1fa067d7105718e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7cd7cf162e9f83adb1fa067d7105718e"></a>
template&lt;typename T , typename... As, size_t... Is&gt; </td></tr>
<tr class="memitem:a7cd7cf162e9f83adb1fa067d7105718e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_function</b> (T &amp;f, std::tuple&lt; As... &gt; &amp;t, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a7cd7cf162e9f83adb1fa067d7105718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f2b7908b774c313f734b268aa1e2c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4f2b7908b774c313f734b268aa1e2c6"></a>
template&lt;typename T , typename... As&gt; </td></tr>
<tr class="memitem:aa4f2b7908b774c313f734b268aa1e2c6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_function</b> (T &amp;f, std::tuple&lt; As... &gt; &amp;t)</td></tr>
<tr class="separator:aa4f2b7908b774c313f734b268aa1e2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c77457377332aff467b0f80500236fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c77457377332aff467b0f80500236fc"></a>
template&lt;typename T , typename... As, size_t... Is&gt; </td></tr>
<tr class="memitem:a9c77457377332aff467b0f80500236fc"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_function_mpi</b> (T &amp;f, std::tuple&lt; As... &gt; &amp;t, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a9c77457377332aff467b0f80500236fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca22ef480c1b73e143f5482dc65a2607"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca22ef480c1b73e143f5482dc65a2607"></a>
template&lt;typename T , typename... As&gt; </td></tr>
<tr class="memitem:aca22ef480c1b73e143f5482dc65a2607"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_function_mpi</b> (T &amp;f, std::tuple&lt; As... &gt; &amp;t)</td></tr>
<tr class="separator:aca22ef480c1b73e143f5482dc65a2607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a36b1df79a91d070d60ccf4da7aab5550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>exodus_g_registered</b></td></tr>
<tr class="separator:a36b1df79a91d070d60ccf4da7aab5550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f40c96f3d935baa1ee06de0fe1d8da4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>exodus_exo_registered</b></td></tr>
<tr class="separator:a0f40c96f3d935baa1ee06de0fe1d8da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>user includes </p>
<p>uncomment to use boost's zip iterator</p>
<p>unomment to use bens original version</p>
<p>courtesy of some other legion code. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2de73bf6840f69aaede970c8eeca407f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mesh_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflecsi.html#a2de73bf6840f69aaede970c8eeca407f">flecsi::io_factory_t</a> = typedef <a class="el" href="classflecsi_1_1Factory__.html">flecsi::Factory_</a>&lt;<a class="el" href="classflecsi_1_1io__base__t.html">io_base_t</a>&lt;<a class="el" href="structmesh__t.html">mesh_t</a>&gt;, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory type definition for io. <a class="el" href="classflecsi_1_1Factory__.html" title="Factory_ provides a generic object factory class. ">flecsi::Factory_</a> templated on <a class="el" href="classflecsi_1_1io__base__t.html" title="io_base_t provides a base class using the object factory with pure virtual functions for read and wri...">io_base_t</a> and string. Used for registering a file extenstion with a factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structmesh__t.html">mesh_t</a></td><td>Mesh to template io factory on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9f027dc30c226754e367fd96e47be099"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class LIST, typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flecsi::centroid </td>
          <td>(</td>
          <td class="paramtype">const LIST&lt; <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vert_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the centroid of a list of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell to return the centroid for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a point_t that is the centroid. </dd></dl>

</div>
</div>
<a class="anchor" id="a17b055e9f2fd8cb9c8556361c1fc2c2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mesh_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1io__base__t.html">io_base_t</a>&lt;<a class="el" href="structmesh__t.html">mesh_t</a>&gt;* flecsi::create_io_exodus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="structflecsi_1_1io__exodus__t.html" title="io_exodus_t provides a derived type of io_base.h and registrations of the exodus file extensions...">io_exodus_t</a> and return a pointer to the base class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structmesh__t.html">mesh_t</a></td><td>Mesh type for <a class="el" href="structflecsi_1_1io__exodus__t.html" title="io_exodus_t provides a derived type of io_base.h and registrations of the exodus file extensions...">io_exodus_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classflecsi_1_1io__base__t.html" title="io_base_t provides a base class using the object factory with pure virtual functions for read and wri...">io_base_t</a> base class of <a class="el" href="structflecsi_1_1io__exodus__t.html" title="io_exodus_t provides a derived type of io_base.h and registrations of the exodus file extensions...">io_exodus_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae00aa0fd0011d23e53e2cd5d5c06b638"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::cross_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cross_magnitude </p>

</div>
</div>
<a class="anchor" id="a8c33ed916021542824dcd39b641043e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::cross_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cross_magnitude </p>

</div>
</div>
<a class="anchor" id="a8e86d3d804972fbb935e736f8ad5ee68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::cross_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cross_magnitude </p>

</div>
</div>
<a class="anchor" id="a3d6425bc674c81543e3b5f0de15f0b9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>distance </p>

</div>
</div>
<a class="anchor" id="a4102871ead95b156dc6ba36f7997dcd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dot </p>

</div>
</div>
<a class="anchor" id="ad632478a9ad09abb8d2e03ae17f07df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flecsi::filter_impl_ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;std::tuple_element_t&lt;Is, T&gt; ...&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use a filter sequence to get elements from an input tuple. </p>

</div>
</div>
<a class="anchor" id="acf440381d22446d7a23fc234b3f5dd7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>magnitude </p>

</div>
</div>
<a class="anchor" id="a52049000b478c401bd80ab5424965c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt;T, D&gt; flecsi::midpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>midpoint </p>

</div>
</div>
<a class="anchor" id="a7a7c372686a27b05898a4808c648149c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt;T, 2&gt; flecsi::normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for a vector xi + yj the normal vector is -yi + xj. given points a and b we use x = b[0] - a[0] and y = b[1] - a[1] </p>
<p>normal </p>

</div>
</div>
<a class="anchor" id="a4d21406e33994f7c8b1ded3e8c556b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt;T, 3&gt; flecsi::normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normal </p>

</div>
</div>
<a class="anchor" id="ae0a2738b3592492e183566d68cb1a612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt;T, D&gt; flecsi::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceflecsi.html#ae0a2738b3592492e183566d68cb1a612">operator*(const space_vector&lt;T,D&gt; &amp; v, const T s)</a> </p>

</div>
</div>
<a class="anchor" id="ac90571855bcc6e564029d77944a2d8da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D, size_t TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt;T, D, TS&gt; flecsi::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator involving two dimensioned_arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array base value type. </td></tr>
    <tr><td class="paramname">D</td><td>The array dimension. </td></tr>
    <tr><td class="paramname">TS</td><td>The <em>type</em> <em>space</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> on the left hand side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> on the right hand side of the operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current object. </dd></dl>

</div>
</div>
<a class="anchor" id="af26f3bc2962eedb1bc41565d2769b5d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D, size_t TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt;T, D, TS&gt; flecsi::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator involving two dimensioned_arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array base value type. </td></tr>
    <tr><td class="paramname">D</td><td>The array dimension. </td></tr>
    <tr><td class="paramname">TS</td><td>The <em>type</em> <em>space</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> on the left hand side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> on the right hand side of the operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current object. </dd></dl>

</div>
</div>
<a class="anchor" id="a97e11ad0e04d2d90c6467c284c70ecf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D, size_t TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; flecsi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">dimensioned_array</a>&lt; T, D, TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output operator for <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array base value type. </td></tr>
    <tr><td class="paramname">D</td><td>The array dimension. </td></tr>
    <tr><td class="paramname">TS</td><td>The <em>type</em> <em>space</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The ostream to dump output to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classflecsi_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> on the right hand side of the operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current ostream. </dd></dl>

</div>
</div>
<a class="anchor" id="ad50ffae3f2ba9b3a3d548cd0a4910998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1dimensioned__array.html">space_vector</a>&lt;T, D&gt; flecsi::point_to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1dimensioned__array.html">point</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents of a point type to a <a class="el" href="classspace__vector.html" title="space_vector defines an interface for storing and manipulating space_vector data associated with a ge...">space_vector</a> type. Because point has template parameter TS = 1, and <a class="el" href="classspace__vector.html" title="space_vector defines an interface for storing and manipulating space_vector data associated with a ge...">space_vector</a> has template parameter TS = 2, the usual copy/assignment constructors don't work as one would hope. There is probably a better way to do this. </p>
<p><a class="el" href="namespaceflecsi.html#ad50ffae3f2ba9b3a3d548cd0a4910998" title="Copies the contents of a point type to a space_vector type. Because point has template parameter TS =...">point_to_vector(const point&lt;T, D&gt; &amp; a)</a> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type. </td></tr>
    <tr><td class="paramname">D</td><td>Mesh dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The point to create a <a class="el" href="classspace__vector.html" title="space_vector defines an interface for storing and manipulating space_vector data associated with a ge...">space_vector</a> from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Space vector with the contents of point <em>p</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f499a58b7832887ba6f2b4c112c7bfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mesh_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t flecsi::read_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmesh__t.html">mesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic mesh reader that calls the correct method based on the suffix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structmesh__t.html">mesh_t</a></td><td>Mesh type to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Read mesh <em>m</em> from <em>name</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Create mesh <em>m</em> from <em>name</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code. 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ef7cabc62cd0e998134cacb38aab3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename P, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flecsi::tuple_filter_ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply predicate to filter tuple. </p>

</div>
</div>
<a class="anchor" id="a81331ddedd4417f7624a9fff1f2ebc52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename P, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flecsi::tuple_filter_index_ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply predicate to filter indices of tuple. </p>

</div>
</div>
<a class="anchor" id="aab161a9166ab366149e43aa6324aa50d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mesh_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t flecsi::write_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmesh__t.html">mesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic mesh writer that calls the correct method based on the suffix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structmesh__t.html">mesh_t</a></td><td>Mesh type to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Write mesh <em>m</em> to <em>name</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Write mesh <em>m</em> to <em>name</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code. 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c10a5cdd3d14eddc69fdfe09f2af1f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mesh_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t flecsi::write_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmesh__t.html">mesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic mesh writer that calls the correct method based on the suffix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structmesh__t.html">mesh_t</a></td><td>Mesh type to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Write mesh <em>m</em> to <em>name</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Write mesh <em>m</em> to <em>name</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A binary flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code. 0 on success. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a0f40c96f3d935baa1ee06de0fe1d8da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flecsi::exodus_exo_registered</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">  <a class="code" href="classflecsi_1_1Factory__.html#a51bd945a2bb25429a57084b1031339f5">io_factory_t&lt;fake_mesh_t&gt;::instance</a>().<a class="code" href="classflecsi_1_1Factory__.html#a05b481a3af3fe114e7eae5053ae93279">registerType</a>(<span class="stringliteral">&quot;exo&quot;</span>, create_io_exodus&lt;fake_mesh_t&gt;)</div><div class="ttc" id="classflecsi_1_1Factory___html_a05b481a3af3fe114e7eae5053ae93279"><div class="ttname"><a href="classflecsi_1_1Factory__.html#a05b481a3af3fe114e7eae5053ae93279">flecsi::Factory_::registerType</a></div><div class="ttdeci">bool registerType(key_t key, createHandler ch)</div><div class="ttdef"><b>Definition:</b> factory.h:65</div></div>
<div class="ttc" id="classflecsi_1_1Factory___html_a51bd945a2bb25429a57084b1031339f5"><div class="ttname"><a href="classflecsi_1_1Factory__.html#a51bd945a2bb25429a57084b1031339f5">flecsi::Factory_::instance</a></div><div class="ttdeci">static Factory_ &amp; instance()</div><div class="ttdef"><b>Definition:</b> factory.h:51</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a36b1df79a91d070d60ccf4da7aab5550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flecsi::exodus_g_registered</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="classflecsi_1_1Factory__.html#a51bd945a2bb25429a57084b1031339f5">io_factory_t&lt;fake_mesh_t&gt;::instance</a>().<a class="code" href="classflecsi_1_1Factory__.html#a05b481a3af3fe114e7eae5053ae93279">registerType</a>(<span class="stringliteral">&quot;g&quot;</span>, create_io_exodus&lt;fake_mesh_t&gt;)</div><div class="ttc" id="classflecsi_1_1Factory___html_a05b481a3af3fe114e7eae5053ae93279"><div class="ttname"><a href="classflecsi_1_1Factory__.html#a05b481a3af3fe114e7eae5053ae93279">flecsi::Factory_::registerType</a></div><div class="ttdeci">bool registerType(key_t key, createHandler ch)</div><div class="ttdef"><b>Definition:</b> factory.h:65</div></div>
<div class="ttc" id="classflecsi_1_1Factory___html_a51bd945a2bb25429a57084b1031339f5"><div class="ttname"><a href="classflecsi_1_1Factory__.html#a51bd945a2bb25429a57084b1031339f5">flecsi::Factory_::instance</a></div><div class="ttdeci">static Factory_ &amp; instance()</div><div class="ttdef"><b>Definition:</b> factory.h:51</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
