<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" type="image/x-icon" href="flecsi-favicon.ico" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Interface Documentation: Data Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" height="200" style="margin-top:40px; margin-left:30px; margin-right:10px" src="medium-flecsi.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Interface Documentation<br>
		<span id="projectnumber">Version:</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Data Interface</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__legion-data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__legion-data.html">Legion Data Backend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__serial-data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial-data.html">Serial Data Backend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1data_1_1data__client__interface____.html">flecsi::data::data_client_interface__&lt; DATA_POLICY &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1dense__accessor__base__t.html">flecsi::dense_accessor_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1accessor_____3_01data_1_1dense_00_01T_00_01EXCLUSIVE__PERMISSIONS_00_01SHARED__Pe927e95b5549d371feaf66e9ea26f6d3.html">flecsi::accessor__&lt; data::dense, T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1dense__data__handle__base__t.html">flecsi::dense_data_handle_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1dense__data__handle__base____.html">flecsi::dense_data_handle_base__&lt; T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS, DATA_POLICY &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1data_1_1field__interface____.html">flecsi::data::field_interface__&lt; DATA_POLICY &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1global__accessor__base__t.html">flecsi::global_accessor_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1accessor_____3_01data_1_1global_00_01T_00_01PERMISSIONS_00_010_00_010_01_4.html">flecsi::accessor__&lt; data::global, T, PERMISSIONS, 0, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1global__data__handle__base__t.html">flecsi::global_data_handle_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1global__data__handle__base____.html">flecsi::global_data_handle_base__&lt; T, PERMISSIONS, DATA_POLICY &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1hpx__mutator__handle__policy__t.html">flecsi::hpx_mutator_handle_policy_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1data_1_1legion_1_1color__handle____.html">flecsi::data::legion::color_handle__&lt; T, PERMISSIONS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1data_1_1legion_1_1dense__handle__t.html">flecsi::data::legion::dense_handle_t&lt; T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1legion__dense__data__handle__policy__t.html">flecsi::legion_dense_data_handle_policy_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1legion__global__data__handle__policy__t.html">flecsi::legion_global_data_handle_policy_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1legion__data__t.html">flecsi::data::legion_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1legion__mutator__handle__policy__t.html">flecsi::legion_mutator_handle_policy_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1legion__sparse__data__handle__policy__t.html">flecsi::legion_sparse_data_handle_policy_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1mpi__mutator__handle__policy__t.html">flecsi::mpi_mutator_handle_policy_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1ragged__accessor__base__t.html">flecsi::ragged_accessor_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1accessor_____3_01data_1_1ragged_00_01T_00_01EXCLUSIVE__PERMISSIONS_00_01SHARED__8a1386b41ca62cd860577183e4bdbe59.html">flecsi::accessor__&lt; data::ragged, T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1ragged__mutator__base__t.html">flecsi::ragged_mutator_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1mutator_____3_01data_1_1ragged_00_01T_01_4.html">flecsi::mutator__&lt; data::ragged, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1sparse__accessor__base__t.html">flecsi::sparse_accessor_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1accessor_____3_01data_1_1sparse_00_01T_00_01EXCLUSIVE__PERMISSIONS_00_01SHARED__ea9975ad170d5f9e7f372254d224f9b3.html">flecsi::accessor__&lt; data::sparse, T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1sparse__mutator__base__t.html">flecsi::sparse_mutator_base_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1mutator_____3_01data_1_1sparse_00_01T_01_4.html">flecsi::mutator__&lt; data::sparse, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1data_1_1storage____.html">flecsi::data::storage__&lt; STORAGE_POLICY &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaaa855ccd1c709526c76247bce774ff64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gaaa855ccd1c709526c76247bce774ff64">flecsi_register_data_client</a>(client_type,  nspace,  name)</td></tr>
<tr class="separator:gaaa855ccd1c709526c76247bce774ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94367ffbedff524f08ddef3a27df2b36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga94367ffbedff524f08ddef3a27df2b36">flecsi_register_field</a>(client_type,  nspace,  name,  data_type,  storage_class,  versions, ...)</td></tr>
<tr class="separator:ga94367ffbedff524f08ddef3a27df2b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2122fc2a0f3dc705a6c6da72a1db513d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga2122fc2a0f3dc705a6c6da72a1db513d">flecsi_register_global</a>(nspace,  name,  data_type,  versions, ...)</td></tr>
<tr class="separator:ga2122fc2a0f3dc705a6c6da72a1db513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9f54d9b214a39f3b11c777dd743e32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga1c9f54d9b214a39f3b11c777dd743e32">flecsi_register_color</a>(nspace,  name,  data_type,  versions, ...)</td></tr>
<tr class="separator:ga1c9f54d9b214a39f3b11c777dd743e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e528276b2480bd22509e4afd6772bdd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">flecsi_get_handle</a>(client_handle,  nspace,  name,  data_type,  storage_class,  version)</td></tr>
<tr class="separator:ga7e528276b2480bd22509e4afd6772bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fe6b51edd61dd0717e9f1c5a364635"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gae3fe6b51edd61dd0717e9f1c5a364635">flecsi_get_global</a>(nspace,  name,  data_type,  version)</td></tr>
<tr class="separator:gae3fe6b51edd61dd0717e9f1c5a364635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1bebd5339abd5554ea4d9c6cb4ff7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gaec1bebd5339abd5554ea4d9c6cb4ff7e">flecsi_get_color</a>(nspace,  name,  data_type,  version)</td></tr>
<tr class="separator:gaec1bebd5339abd5554ea4d9c6cb4ff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9673dfe687ab0a65683d20689bd9cc46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga9673dfe687ab0a65683d20689bd9cc46">flecsi_get_client_handle</a>(client_type,  nspace,  name)</td></tr>
<tr class="separator:ga9673dfe687ab0a65683d20689bd9cc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27bde67f88afc6db9dfce68925da182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gae27bde67f88afc6db9dfce68925da182">flecsi_get_handles</a>(client,  nspace,  data_type,  storage_class,  version, ...)</td></tr>
<tr class="separator:gae27bde67f88afc6db9dfce68925da182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073e18a5ae86ed46a119cb342b5c09c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga073e18a5ae86ed46a119cb342b5c09c1">flecsi_get_handles_all</a>(client,  data_type,  storage_class,  version, ...)</td></tr>
<tr class="separator:ga073e18a5ae86ed46a119cb342b5c09c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151ea5ef345db39934ea8c149074e53b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga151ea5ef345db39934ea8c149074e53b">flecsi_is_at</a>(index_space)</td></tr>
<tr class="separator:ga151ea5ef345db39934ea8c149074e53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8e9b647fcc580ef5857ad14db4877c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga8e8e9b647fcc580ef5857ad14db4877c">flecsi_has_attribute_at</a>(attribute,  index_space)</td></tr>
<tr class="separator:ga8e8e9b647fcc580ef5857ad14db4877c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe93336f4e608acaf933c262e31ca670"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gabe93336f4e608acaf933c262e31ca670">flecsi_has_attribute</a>(attribute)</td></tr>
<tr class="separator:gabe93336f4e608acaf933c262e31ca670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07598e722b50beb7c7b9ce0e03108143"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga07598e722b50beb7c7b9ce0e03108143">flecsi_get_mutator</a>(client_handle,  nspace,  name,  data_type,  storage_class,  version,  slots)</td></tr>
<tr class="separator:ga07598e722b50beb7c7b9ce0e03108143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7ec0a7a6abde96d9d690d57cc60627db"><td class="memTemplParams" colspan="2">template&lt;typename DATA_CLIENT_TYPE , size_t PERMISSIONS&gt; </td></tr>
<tr class="memitem:ga7ec0a7a6abde96d9d690d57cc60627db"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga7ec0a7a6abde96d9d690d57cc60627db">flecsi::data_client_handle__</a> = data_client_handle_base__&lt; DATA_CLIENT_TYPE, PERMISSIONS, FLECSI_RUNTIME_DATA_CLIENT_HANDLE_POLICY &gt;</td></tr>
<tr class="separator:ga7ec0a7a6abde96d9d690d57cc60627db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91f8413dd1bed8fbbae11b428056b90"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t EXCLUSIVE_PERMISSIONS, size_t SHARED_PERMISSIONS, size_t GHOST_PERMISSIONS&gt; </td></tr>
<tr class="memitem:gad91f8413dd1bed8fbbae11b428056b90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gad91f8413dd1bed8fbbae11b428056b90">flecsi::dense_data_handle__</a> = dense_data_handle_base__&lt; T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS, FLECSI_RUNTIME_DENSE_DATA_HANDLE_POLICY &gt;</td></tr>
<tr class="separator:gad91f8413dd1bed8fbbae11b428056b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e50114ea1c023eeade58540bb92f45a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t PERMISSIONS&gt; </td></tr>
<tr class="memitem:ga7e50114ea1c023eeade58540bb92f45a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga7e50114ea1c023eeade58540bb92f45a">flecsi::global_data_handle__</a> = global_data_handle_base__&lt; T, PERMISSIONS, FLECSI_RUNTIME_GLOBAL_DATA_HANDLE_POLICY &gt;</td></tr>
<tr class="separator:ga7e50114ea1c023eeade58540bb92f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c01e1f14ff1bae1c3aa73955ddc0c45"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t EXCLUSIVE_PERMISSIONS, size_t SHARED_PERMISSIONS, size_t GHOST_PERMISSIONS&gt; </td></tr>
<tr class="memitem:ga5c01e1f14ff1bae1c3aa73955ddc0c45"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga5c01e1f14ff1bae1c3aa73955ddc0c45">flecsi::sparse_data_handle__</a> = sparse_data_handle_base__&lt; T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS, FLECSI_RUNTIME_SPARSE_DATA_HANDLE_POLICY &gt;</td></tr>
<tr class="separator:ga5c01e1f14ff1bae1c3aa73955ddc0c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga171757e2b3f34c74747d15e6adde43e9"><td class="memTemplParams" colspan="2">template&lt;typename DATA_CLIENT_TYPE , size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, size_t NAME_HASH, size_t VERSIONS, size_t INDEX_SPACE = 0&gt; </td></tr>
<tr class="memitem:ga171757e2b3f34c74747d15e6adde43e9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">flecsi::data::field_interface__&lt; DATA_POLICY &gt;::register_field</a> (std::string const &amp;name)</td></tr>
<tr class="separator:ga171757e2b3f34c74747d15e6adde43e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632a4a77646537c08274c4211ee5d743"><td class="memTemplParams" colspan="2">template&lt;typename DATA_CLIENT_TYPE , size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, size_t NAME_HASH, size_t VERSION = 0, size_t PERMISSIONS&gt; </td></tr>
<tr class="memitem:ga632a4a77646537c08274c4211ee5d743"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga632a4a77646537c08274c4211ee5d743">flecsi::data::field_interface__&lt; DATA_POLICY &gt;::get_handle</a> (const data_client_handle__&lt; DATA_CLIENT_TYPE, PERMISSIONS &gt; &amp;client_handle)</td></tr>
<tr class="separator:ga632a4a77646537c08274c4211ee5d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga215f6270abc3674c6c85ce49f5d027a3"><td class="memTemplParams" colspan="2">template&lt;typename DATA_CLIENT_TYPE , size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, size_t NAME_HASH, size_t VERSION = 0, size_t PERMISSIONS&gt; </td></tr>
<tr class="memitem:ga215f6270abc3674c6c85ce49f5d027a3"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga215f6270abc3674c6c85ce49f5d027a3">flecsi::data::field_interface__&lt; DATA_POLICY &gt;::get_mutator</a> (const data_client_handle__&lt; DATA_CLIENT_TYPE, PERMISSIONS &gt; &amp;client_handle, size_t slots)</td></tr>
<tr class="separator:ga215f6270abc3674c6c85ce49f5d027a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1ee7eaa990865b8be70ccd71812f61"><td class="memTemplParams" colspan="2">template&lt;size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, typename PREDICATE &gt; </td></tr>
<tr class="memitem:ga8c1ee7eaa990865b8be70ccd71812f61"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">flecsi::data::field_interface__&lt; DATA_POLICY &gt;::get_handles</a> (const data_client_t &amp;client, size_t version, PREDICATE &amp;&amp;predicate, bool sorted=true)</td></tr>
<tr class="separator:ga8c1ee7eaa990865b8be70ccd71812f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4454c2ce12bc1ce7f3a132dfecbddbb3"><td class="memTemplParams" colspan="2">template&lt;size_t STORAGE_CLASS, typename DATA_TYPE , typename PREDICATE &gt; </td></tr>
<tr class="memitem:ga4454c2ce12bc1ce7f3a132dfecbddbb3"><td class="memTemplItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga4454c2ce12bc1ce7f3a132dfecbddbb3">flecsi::data::field_interface__&lt; DATA_POLICY &gt;::get_handles</a> (const data_client_t &amp;client, size_t version, PREDICATE &amp;&amp;predicate, bool sorted=true)</td></tr>
<tr class="separator:ga4454c2ce12bc1ce7f3a132dfecbddbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Define the Data Model group. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9673dfe687ab0a65683d20689bd9cc46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_client_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to get a handle to the data client */</span>             \</div><div class="line">  flecsi::data::data_client_interface_t::get_client_handle&lt;                    \</div><div class="line">      client_type,                                                             \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),      \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash()&gt;()</div></div><!-- fragment --><p>Access a data client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The data_client_t type. </td></tr>
    <tr><td class="paramname">nspace</td><td>The namespace to use to access the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec1bebd5339abd5554ea4d9c6cb4ff7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_color</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">version&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* WARNING: This macro returns a handle. Don&#39;t add terminations! */</span>          <a class="code" href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">\</a></div><div class="line"><a class="code" href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">  flecsi_get_handle</a>(                                                           \</div><div class="line">      <a class="code" href="group__data.html#ga9673dfe687ab0a65683d20689bd9cc46">flecsi_get_client_handle</a>(                                                \</div><div class="line">          <a class="code" href="structflecsi_1_1data_1_1color__data__client__t.html">flecsi::data::color_data_client_t</a>, color_client, color_client),      \</div><div class="line">      nspace, name, data_type, color, version)</div><div class="ttc" id="group__data_html_ga9673dfe687ab0a65683d20689bd9cc46"><div class="ttname"><a href="group__data.html#ga9673dfe687ab0a65683d20689bd9cc46">flecsi_get_client_handle</a></div><div class="ttdeci">#define flecsi_get_client_handle(client_type, nspace, name)</div><div class="ttdef"><b>Definition:</b> data.h:236</div></div>
<div class="ttc" id="group__data_html_ga7e528276b2480bd22509e4afd6772bdd"><div class="ttname"><a href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">flecsi_get_handle</a></div><div class="ttdeci">#define flecsi_get_handle(client_handle, nspace, name, data_type, storage_class, version)</div><div class="ttdef"><b>Definition:</b> data.h:163</div></div>
<div class="ttc" id="structflecsi_1_1data_1_1color__data__client__t_html"><div class="ttname"><a href="structflecsi_1_1data_1_1color__data__client__t.html">flecsi::data::color_data_client_t</a></div><div class="ttdef"><b>Definition:</b> internal_client.h:34</div></div>
</div><!-- fragment --><p>Access color data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nspace</td><td>The namespace to use to access the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to access. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to access, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">version</td><td>The version number of the data to access. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3fe6b51edd61dd0717e9f1c5a364635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_global</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">version&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* WARNING: This macro returns a handle. Don&#39;t add terminations! */</span>          <a class="code" href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">\</a></div><div class="line"><a class="code" href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">  flecsi_get_handle</a>(                                                           \</div><div class="line">      <a class="code" href="group__data.html#ga9673dfe687ab0a65683d20689bd9cc46">flecsi_get_client_handle</a>(                                                \</div><div class="line">          <a class="code" href="structflecsi_1_1data_1_1global__data__client__t.html">flecsi::data::global_data_client_t</a>, global_client, global_client),   \</div><div class="line">      nspace, name, data_type, global, version)</div><div class="ttc" id="group__data_html_ga9673dfe687ab0a65683d20689bd9cc46"><div class="ttname"><a href="group__data.html#ga9673dfe687ab0a65683d20689bd9cc46">flecsi_get_client_handle</a></div><div class="ttdeci">#define flecsi_get_client_handle(client_type, nspace, name)</div><div class="ttdef"><b>Definition:</b> data.h:236</div></div>
<div class="ttc" id="group__data_html_ga7e528276b2480bd22509e4afd6772bdd"><div class="ttname"><a href="group__data.html#ga7e528276b2480bd22509e4afd6772bdd">flecsi_get_handle</a></div><div class="ttdeci">#define flecsi_get_handle(client_handle, nspace, name, data_type, storage_class, version)</div><div class="ttdef"><b>Definition:</b> data.h:163</div></div>
<div class="ttc" id="structflecsi_1_1data_1_1global__data__client__t_html"><div class="ttname"><a href="structflecsi_1_1data_1_1global__data__client__t.html">flecsi::data::global_data_client_t</a></div><div class="ttdef"><b>Definition:</b> internal_client.h:27</div></div>
</div><!-- fragment --><p>Access global data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nspace</td><td>The namespace to use to access the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to access. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to access, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">storage_class</td><td>The storage type for the data storage_class_t. </td></tr>
    <tr><td class="paramname">version</td><td>The version number of the data to access. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e528276b2480bd22509e4afd6772bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage_class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">version&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to get a handle to the data */</span>                    <a class="code" href="group__data.html#ga632a4a77646537c08274c4211ee5d743">\</a></div><div class="line"><a class="code" href="group__data.html#ga632a4a77646537c08274c4211ee5d743">  flecsi::data::field_interface_t::get_handle</a>&lt;                                 \</div><div class="line">      typename <a class="code" href="structflecsi_1_1data__client__type____.html">flecsi::data_client_type__&lt;decltype(client_handle)&gt;::type</a>,      \</div><div class="line">      flecsi::data::storage_class, data_type,                                  \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),      \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash(),        \</div><div class="line">      version&gt;(client_handle)</div><div class="ttc" id="group__data_html_ga632a4a77646537c08274c4211ee5d743"><div class="ttname"><a href="group__data.html#ga632a4a77646537c08274c4211ee5d743">flecsi::data::field_interface__::get_handle</a></div><div class="ttdeci">static decltype(auto) get_handle(const data_client_handle__&lt; DATA_CLIENT_TYPE, PERMISSIONS &gt; &amp;client_handle)</div><div class="ttdef"><b>Definition:</b> field.h:123</div></div>
<div class="ttc" id="structflecsi_1_1data__client__type_____html"><div class="ttname"><a href="structflecsi_1_1data__client__type____.html">flecsi::data_client_type__</a></div><div class="ttdef"><b>Definition:</b> data_client_handle.h:68</div></div>
</div><!-- fragment --><p>Access data with a data_client_t instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The data_client_t instance with which to access the data. </td></tr>
    <tr><td class="paramname">nspace</td><td>The namespace to use to access the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to access. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to access, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">storage_class</td><td>The storage type for the data storage_class_t. </td></tr>
    <tr><td class="paramname">version</td><td>The version number of the data to access. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae27bde67f88afc6db9dfce68925da182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_handles</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage_class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">version, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to get the handles to the data */</span>                 <a class="code" href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">\</a></div><div class="line"><a class="code" href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">  flecsi::data::field_interface_t::get_handles</a>&lt;                                \</div><div class="line">      flecsi::data::storage_class, data_type,                                  \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash()&gt;(     \</div><div class="line">      client, version, ##__VA_ARGS__)</div><div class="ttc" id="group__data_html_ga8c1ee7eaa990865b8be70ccd71812f61"><div class="ttname"><a href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">flecsi::data::field_interface__::get_handles</a></div><div class="ttdeci">static decltype(auto) get_handles(const data_client_t &amp;client, size_t version, PREDICATE &amp;&amp;predicate, bool sorted=true)</div><div class="ttdef"><b>Definition:</b> field.h:205</div></div>
</div><!-- fragment --><p>Get a list of all accessors in the namespace of a certain type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The data_client_t instance with which to access the data. </td></tr>
    <tr><td class="paramname">nspace</td><td>The namespace to use to access the variables. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to access, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">storage_class</td><td>The storage type for the data storage_class_t. </td></tr>
    <tr><td class="paramname">version</td><td>The version number of the data to access. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate function to test an accessor against to figure out whether it get added to the returned list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This version is confined to search only within a namespace. </dd></dl>

</div>
</div>
<a class="anchor" id="ga073e18a5ae86ed46a119cb342b5c09c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_handles_all</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage_class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">version, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to get the handles to the data */</span>                 <a class="code" href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">\</a></div><div class="line"><a class="code" href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">  flecsi::data::field_interface_t::get_handles</a>&lt;                                \</div><div class="line">      flecsi::data::storage_class, data_type&gt;(client, version, ##__VA_ARGS__)</div><div class="ttc" id="group__data_html_ga8c1ee7eaa990865b8be70ccd71812f61"><div class="ttname"><a href="group__data.html#ga8c1ee7eaa990865b8be70ccd71812f61">flecsi::data::field_interface__::get_handles</a></div><div class="ttdeci">static decltype(auto) get_handles(const data_client_t &amp;client, size_t version, PREDICATE &amp;&amp;predicate, bool sorted=true)</div><div class="ttdef"><b>Definition:</b> field.h:205</div></div>
</div><!-- fragment --><p>Get a list of all accessors in the namespace of a certain type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The data_client_t instance with which to access the data from. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to access, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">storage_class</td><td>The storage type for the data storage_class_t. </td></tr>
    <tr><td class="paramname">version</td><td>The version number of the data to access. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate function to test an accessor against to figure out whether it get added to the returned list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This version searches all namespaces. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07598e722b50beb7c7b9ce0e03108143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_get_mutator</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client_handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage_class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">version, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slots&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to get a handle to the data */</span>                    <a class="code" href="group__data.html#ga215f6270abc3674c6c85ce49f5d027a3">\</a></div><div class="line"><a class="code" href="group__data.html#ga215f6270abc3674c6c85ce49f5d027a3">  flecsi::data::field_interface_t::get_mutator</a>&lt;                                \</div><div class="line">      typename <a class="code" href="structflecsi_1_1data__client__type____.html">flecsi::data_client_type__&lt;decltype(client_handle)&gt;::type</a>,      \</div><div class="line">      flecsi::data::storage_class, data_type,                                  \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),      \</div><div class="line">      flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash(),        \</div><div class="line">      version&gt;(client_handle, slots)</div><div class="ttc" id="structflecsi_1_1data__client__type_____html"><div class="ttname"><a href="structflecsi_1_1data__client__type____.html">flecsi::data_client_type__</a></div><div class="ttdef"><b>Definition:</b> data_client_handle.h:68</div></div>
<div class="ttc" id="group__data_html_ga215f6270abc3674c6c85ce49f5d027a3"><div class="ttname"><a href="group__data.html#ga215f6270abc3674c6c85ce49f5d027a3">flecsi::data::field_interface__::get_mutator</a></div><div class="ttdeci">static decltype(auto) get_mutator(const data_client_handle__&lt; DATA_CLIENT_TYPE, PERMISSIONS &gt; &amp;client_handle, size_t slots)</div><div class="ttdef"><b>Definition:</b> field.h:164</div></div>
</div><!-- fragment --><p>Get a mutator handle for sparse data. A mutator allows for the sparse allocation of new entries associated with an index as well as for erasing existing entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_handle</td><td>the data client handle </td></tr>
    <tr><td class="paramname">nspace</td><td>data namespace </td></tr>
    <tr><td class="paramname">name</td><td>data names </td></tr>
    <tr><td class="paramname">data_type</td><td>data type e.g. float, long &ndash; any data type so long as it is trivially copyable </td></tr>
    <tr><td class="paramname">storage_class</td><td>storage class, e.g. dense, sparse </td></tr>
    <tr><td class="paramname">version</td><td>version number </td></tr>
    <tr><td class="paramname">slots</td><td>number of slots to use for data commit &ndash; for optimal performance this should roughly be set to the expected number of entries that will be inserted per index although, it is fine if the number of inserted entries exceeds this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mutator handle </dd></dl>

</div>
</div>
<a class="anchor" id="gabe93336f4e608acaf933c262e31ca670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_has_attribute</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attribute</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Define a lambda predicate function to test the attribute */</span>               \</div><div class="line">  [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; a) { <span class="keywordflow">return</span> a.attributes().test(attribute); }</div></div><!-- fragment --><p>Test variables for a particular attribute.</p>
<p>Predicate function to select state variables that have been tagged with some attribute AND are defined in a specific virtual index space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>The attribute to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the state is persistent and is registered in the specified virtual index space, false, otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The index_space can't match anything in the underlying storage container. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e8e9b647fcc580ef5857ad14db4877c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_has_attribute_at</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attribute, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index_space&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Define a lambda function predicate to select the index space */</span>           \</div><div class="line">  [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; a) {                                                         \</div><div class="line">    return a.attributes().test(attribute) &amp;&amp; a.index_space() == index_space;   \</div><div class="line">  }</div></div><!-- fragment --><p>Select specific variables in an index space with an attribute.</p>
<p>Predicate function to select state variables that have been tagged with some attribute AND are defined in a specific virtual index space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>The attribute to search. </td></tr>
    <tr><td class="paramname">index_space</td><td>State data must be registered in this index space to meet the predicate criterium. Valid index spaces depend on the particular specialization in use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the state is persistent and is registered in the specified virtual index space, false, otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The index_space can't match anything in the underlying storage container. </dd></dl>

</div>
</div>
<a class="anchor" id="ga151ea5ef345db39934ea8c149074e53b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_is_at</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index_space</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Define a lambda function predicate to test the index space */</span>             \</div><div class="line">  [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; a) { <span class="keywordflow">return</span> a.index_space() == index_space; }</div></div><!-- fragment --><p>Select state variables in the given virtual index space. This macro defines a predicate function to select the virtual index space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_space</td><td>State data must be registered in this index space to meet the predicate criterium. Valid index spaces depend on the particular specialization in use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the state is registered in the specified virtual index space, false, otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The index_space can't match anything in the underlying storage container. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c9f54d9b214a39f3b11c777dd743e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_register_color</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versions, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to register the data */</span>                           \</div><div class="line">  bool client_type##_##nspace##_##name##_data_registered =                     <a class="code" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">\</a></div><div class="line"><a class="code" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">      flecsi::data::field_interface_t::register_field</a>&lt;                         \</div><div class="line">          flecsi::data::color_data_client_t, flecsi::data::color, data_type,   \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),  \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash(),    \</div><div class="line">          versions, flecsi::execution::internal_index_space::color_is,         \</div><div class="line"><span class="preprocessor">          ##__VA_ARGS__&gt;({EXPAND_AND_STRINGIFY(name)})</span></div><div class="ttc" id="group__data_html_ga171757e2b3f34c74747d15e6adde43e9"><div class="ttname"><a href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">flecsi::data::field_interface__::register_field</a></div><div class="ttdeci">static bool register_field(std::string const &amp;name)</div><div class="ttdef"><b>Definition:</b> field.h:71</div></div>
</div><!-- fragment --><p>This macro registers color field data. This call does not necessarily cause memory to be allocated. It's primary function is to describe the field data to the runtime. Memory allocation will likely be deferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nspace</td><td>The namespace to use to register the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to register. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to store, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">versions</td><td>The number of versions of the data to register. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa855ccd1c709526c76247bce774ff64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_register_data_client</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to register the data */</span>                           \</div><div class="line">  bool client_type##_##nspace##_##name##_data_client_registered =              <a class="code" href="structflecsi_1_1data_1_1data__client__interface____.html#a5dca4c39f1041507dcdeae31048062c1">\</a></div><div class="line"><a class="code" href="structflecsi_1_1data_1_1data__client__interface____.html#a5dca4c39f1041507dcdeae31048062c1">      flecsi::data::data_client_interface_t::register_data_client</a>&lt;             \</div><div class="line">          client_type,                                                         \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),  \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash()&gt;(   \</div><div class="line">          {EXPAND_AND_STRINGIFY(name)})</div><div class="ttc" id="structflecsi_1_1data_1_1data__client__interface_____html_a5dca4c39f1041507dcdeae31048062c1"><div class="ttname"><a href="structflecsi_1_1data_1_1data__client__interface____.html#a5dca4c39f1041507dcdeae31048062c1">flecsi::data::data_client_interface__::register_data_client</a></div><div class="ttdeci">static bool register_data_client(std::string const &amp;name)</div><div class="ttdef"><b>Definition:</b> client.h:613</div></div>
</div><!-- fragment --><p>This macro registers a data client with the FleCSI runtime. This call does not necessarily cause memory to be allocated. It's primary function is to describe the data to the runtime. Memory allocation will likely be deferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_type</td><td>The data_client_t type. </td></tr>
    <tr><td class="paramname">nspace</td><td>The namespace to use to register the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94367ffbedff524f08ddef3a27df2b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_register_field</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">client_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage_class, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versions, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to register the data */</span>                           \</div><div class="line">  bool client_type##_##nspace##_##name##_data_registered =                     <a class="code" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">\</a></div><div class="line"><a class="code" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">      flecsi::data::field_interface_t::register_field</a>&lt;                         \</div><div class="line">          client_type, flecsi::data::storage_class, data_type,                 \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),  \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash(),    \</div><div class="line">          versions, ##__VA_ARGS__&gt;({EXPAND_AND_STRINGIFY(name)})</div><div class="ttc" id="group__data_html_ga171757e2b3f34c74747d15e6adde43e9"><div class="ttname"><a href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">flecsi::data::field_interface__::register_field</a></div><div class="ttdeci">static bool register_field(std::string const &amp;name)</div><div class="ttdef"><b>Definition:</b> field.h:71</div></div>
</div><!-- fragment --><p>This macro registers field data with a data_client_t type. Data registration creates a data attribute for the given client type. This call does not necessarily cause memory to be allocated. It's primary function is to describe the field data to the runtime. Memory allocation will likely be deferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_type</td><td>The data_client_t type. </td></tr>
    <tr><td class="paramname">nspace</td><td>The namespace to use to register the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to register. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to store, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">storage_class</td><td>The storage type for the data storage_class_t. </td></tr>
    <tr><td class="paramname">versions</td><td>The number of versions of the data to register. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2122fc2a0f3dc705a6c6da72a1db513d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define flecsi_register_global</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nspace, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versions, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* MACRO IMPLEMENTATION */</span>                                                   \</div><div class="line">                                                                               \</div><div class="line">  <span class="comment">/* Call the storage policy to register the data */</span>                           \</div><div class="line">  bool client_type##_##nspace##_##name##_data_registered =                     <a class="code" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">\</a></div><div class="line"><a class="code" href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">      flecsi::data::field_interface_t::register_field</a>&lt;                         \</div><div class="line">          flecsi::data::global_data_client_t, flecsi::data::global, data_type, \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(nspace)}.hash(),  \</div><div class="line">          flecsi::utils::const_string_t{EXPAND_AND_STRINGIFY(name)}.hash(),    \</div><div class="line">          versions, flecsi::execution::internal_index_space::global_is,        \</div><div class="line"><span class="preprocessor">      ##__VA_ARGS__&gt;({EXPAND_AND_STRINGIFY(name)})</span></div><div class="ttc" id="group__data_html_ga171757e2b3f34c74747d15e6adde43e9"><div class="ttname"><a href="group__data.html#ga171757e2b3f34c74747d15e6adde43e9">flecsi::data::field_interface__::register_field</a></div><div class="ttdeci">static bool register_field(std::string const &amp;name)</div><div class="ttdef"><b>Definition:</b> field.h:71</div></div>
</div><!-- fragment --><p>This macro registers global field data. This call does not necessarily cause memory to be allocated. It's primary function is to describe the field data to the runtime. Memory allocation will likely be deferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nspace</td><td>The namespace to use to register the variable. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the data variable to register. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to store, e.g., double or my_type_t. </td></tr>
    <tr><td class="paramname">storage_class</td><td>The storage type for the data storage_class_t. </td></tr>
    <tr><td class="paramname">versions</td><td>The number of versions of the data to register. This parameter can be used to manage multiple data versions, e.g., for new and old state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga7ec0a7a6abde96d9d690d57cc60627db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_CLIENT_TYPE , size_t PERMISSIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#ga7ec0a7a6abde96d9d690d57cc60627db">flecsi::data_client_handle__</a> = typedef data_client_handle_base__&lt; DATA_CLIENT_TYPE, PERMISSIONS, FLECSI_RUNTIME_DATA_CLIENT_HANDLE_POLICY&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data_handle__ type is the high-level data handle type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATA_CLIENT_TYPE</td><td>The client type. </td></tr>
    <tr><td class="paramname">DATA_POLICY</td><td>The data policy for this handle type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad91f8413dd1bed8fbbae11b428056b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t EXCLUSIVE_PERMISSIONS, size_t SHARED_PERMISSIONS, size_t GHOST_PERMISSIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#gad91f8413dd1bed8fbbae11b428056b90">flecsi::dense_data_handle__</a> = typedef dense_data_handle_base__&lt; T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS, FLECSI_RUNTIME_DENSE_DATA_HANDLE_POLICY&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The dense_data_handle__ type is the high-level data handle type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type referenced by the handle. </td></tr>
    <tr><td class="paramname">EXCLUSIVE_PERMISSIONS</td><td>The permissions required on the exclusive indices of the index partition. </td></tr>
    <tr><td class="paramname">SHARED_PERMISSIONS</td><td>The permissions required on the shared indices of the index partition. </td></tr>
    <tr><td class="paramname">GHOST_PERMISSIONS</td><td>The permissions required on the ghost indices of the index partition. </td></tr>
    <tr><td class="paramname">DATA_POLICY</td><td>The data policy for this handle type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e50114ea1c023eeade58540bb92f45a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t PERMISSIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#ga7e50114ea1c023eeade58540bb92f45a">flecsi::global_data_handle__</a> = typedef global_data_handle_base__&lt; T, PERMISSIONS, FLECSI_RUNTIME_GLOBAL_DATA_HANDLE_POLICY&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The global_data_handle__ type is the high-level data handle type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type referenced by the handle. </td></tr>
    <tr><td class="paramname">PERMISSIONS</td><td>The permissions required on the exclusive indices of the index partition. </td></tr>
    <tr><td class="paramname">DATA_POLICY</td><td>The data policy for this handle type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c01e1f14ff1bae1c3aa73955ddc0c45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t EXCLUSIVE_PERMISSIONS, size_t SHARED_PERMISSIONS, size_t GHOST_PERMISSIONS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#ga5c01e1f14ff1bae1c3aa73955ddc0c45">flecsi::sparse_data_handle__</a> = typedef sparse_data_handle_base__&lt; T, EXCLUSIVE_PERMISSIONS, SHARED_PERMISSIONS, GHOST_PERMISSIONS, FLECSI_RUNTIME_SPARSE_DATA_HANDLE_POLICY&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data_handle__ type is the high-level data handle type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type referenced by the handle. </td></tr>
    <tr><td class="paramname">EXCLUSIVE_PERMISSIONS</td><td>The permissions required on the exclusive indices of the index partition. </td></tr>
    <tr><td class="paramname">SHARED_PERMISSIONS</td><td>The permissions required on the shared indices of the index partition. </td></tr>
    <tr><td class="paramname">GHOST_PERMISSIONS</td><td>The permissions required on the ghost indices of the index partition. </td></tr>
    <tr><td class="paramname">DATA_POLICY</td><td>The data policy for this handle type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga632a4a77646537c08274c4211ee5d743"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_POLICY &gt; </div>
<div class="memtemplate">
template&lt;typename DATA_CLIENT_TYPE , size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, size_t NAME_HASH, size_t VERSION = 0, size_t PERMISSIONS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structflecsi_1_1data_1_1field__interface____.html">flecsi::data::field_interface__</a>&lt; DATA_POLICY &gt;::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__data.html#ga7ec0a7a6abde96d9d690d57cc60627db">data_client_handle__</a>&lt; DATA_CLIENT_TYPE, PERMISSIONS &gt; &amp;&#160;</td>
          <td class="paramname"><em>client_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the handle associated with the given parameters and data client.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATA_CLIENT_TYPE</td><td>The data client type on which the data attribute should be registered. </td></tr>
    <tr><td class="paramname">STORAGE_CLASS</td><td>The storage type for the data attribute. </td></tr>
    <tr><td class="paramname">DATA_TYPE</td><td>The data type, e.g., double. This may be P.O.D. or a user-defined type that is trivially-copyable. </td></tr>
    <tr><td class="paramname">NAMESPACE_HASH</td><td>The namespace key. Namespaces allow separation of attribute names to avoid collisions. </td></tr>
    <tr><td class="paramname">NAME_HASH</td><td>The attribute name. </td></tr>
    <tr><td class="paramname">INDEX_SPACE</td><td>The index space identifier. </td></tr>
    <tr><td class="paramname">VERSION</td><td>The data version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c1ee7eaa990865b8be70ccd71812f61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_POLICY &gt; </div>
<div class="memtemplate">
template&lt;size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, typename PREDICATE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structflecsi_1_1data_1_1field__interface____.html">flecsi::data::field_interface__</a>&lt; DATA_POLICY &gt;::get_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1data_1_1data__client__t.html">data_client_t</a> &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PREDICATE &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all handles of the given storage type, data type, and namespace that satisfy a predicate function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STORAGE_CLASS</td><td>The storage type for the data attribute. </td></tr>
    <tr><td class="paramname">DATA_TYPE</td><td>The data type, e.g., double. This may be P.O.D. or a user-defined type that is trivially-copyable. </td></tr>
    <tr><td class="paramname">NAMESPACE_HASH</td><td>The namespace key. Namespaces allow separation of attribute names to avoid collisions. </td></tr>
    <tr><td class="paramname">PREDICATE</td><td>The data version.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The data client instance. </td></tr>
    <tr><td class="paramname">version</td><td>The data version to return. </td></tr>
    <tr><td class="paramname">predicate</td><td>An instance of the predicate function that will be used to select the individual data elements. </td></tr>
    <tr><td class="paramname">sorted</td><td>Put the return data into sorted order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4454c2ce12bc1ce7f3a132dfecbddbb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_POLICY &gt; </div>
<div class="memtemplate">
template&lt;size_t STORAGE_CLASS, typename DATA_TYPE , typename PREDICATE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structflecsi_1_1data_1_1field__interface____.html">flecsi::data::field_interface__</a>&lt; DATA_POLICY &gt;::get_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1data_1_1data__client__t.html">data_client_t</a> &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PREDICATE &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all handles of the given storage type, and data type that satisfy a predicate function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STORAGE_CLASS</td><td>The storage type for the data attribute. </td></tr>
    <tr><td class="paramname">DATA_TYPE</td><td>The data type, e.g., double. This may be P.O.D. or a user-defined type that is trivially-copyable. </td></tr>
    <tr><td class="paramname">PREDICATE</td><td>The data version.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The data client instance. </td></tr>
    <tr><td class="paramname">version</td><td>The data version to return. </td></tr>
    <tr><td class="paramname">predicate</td><td>An instance of the predicate function that will be used to select the individual data elements. </td></tr>
    <tr><td class="paramname">sorted</td><td>Put the return data into sorted order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga215f6270abc3674c6c85ce49f5d027a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_POLICY &gt; </div>
<div class="memtemplate">
template&lt;typename DATA_CLIENT_TYPE , size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, size_t NAME_HASH, size_t VERSION = 0, size_t PERMISSIONS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(auto) <a class="el" href="structflecsi_1_1data_1_1field__interface____.html">flecsi::data::field_interface__</a>&lt; DATA_POLICY &gt;::get_mutator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__data.html#ga7ec0a7a6abde96d9d690d57cc60627db">data_client_handle__</a>&lt; DATA_CLIENT_TYPE, PERMISSIONS &gt; &amp;&#160;</td>
          <td class="paramname"><em>client_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mutator associated with the given parameters and data client.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATA_CLIENT_TYPE</td><td>The data client type on which the data attribute should be registered. </td></tr>
    <tr><td class="paramname">STORAGE_CLASS</td><td>The storage type for the data attribute. </td></tr>
    <tr><td class="paramname">DATA_TYPE</td><td>The data type, e.g., double. This may be P.O.D. or a user-defined type that is trivially-copyable. </td></tr>
    <tr><td class="paramname">NAMESPACE_HASH</td><td>The namespace key. Namespaces allow separation of attribute names to avoid collisions. </td></tr>
    <tr><td class="paramname">NAME_HASH</td><td>The attribute name. </td></tr>
    <tr><td class="paramname">INDEX_SPACE</td><td>The index space identifier. </td></tr>
    <tr><td class="paramname">VERSION</td><td>The data version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga171757e2b3f34c74747d15e6adde43e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_POLICY &gt; </div>
<div class="memtemplate">
template&lt;typename DATA_CLIENT_TYPE , size_t STORAGE_CLASS, typename DATA_TYPE , size_t NAMESPACE_HASH, size_t NAME_HASH, size_t VERSIONS, size_t INDEX_SPACE = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structflecsi_1_1data_1_1field__interface____.html">flecsi::data::field_interface__</a>&lt; DATA_POLICY &gt;::register_field </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a field with the FleCSI runtime. This method should be thought of as registering a field attribute on the given data client type. All instances of the client type will have this attribute. However, this does not mean that each data client instance will have an an instance of the attribute. Attribute instances will be created only when they are actually mapped into a task.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATA_CLIENT_TYPE</td><td>The data client type on which the data attribute should be registered. </td></tr>
    <tr><td class="paramname">STORAGE_CLASS</td><td>The storage type for the data attribute. </td></tr>
    <tr><td class="paramname">DATA_TYPE</td><td>The data type, e.g., double. This may be P.O.D. or a user-defined type that is trivially-copyable. </td></tr>
    <tr><td class="paramname">NAMESPACE_HASH</td><td>The namespace key. Namespaces allow separation of attribute names to avoid collisions. </td></tr>
    <tr><td class="paramname">NAME_HASH</td><td>The attribute name. </td></tr>
    <tr><td class="paramname">INDEX_SPACE</td><td>The index space identifier. </td></tr>
    <tr><td class="paramname">VERSIONS</td><td>The number of versions that shall be associated with this attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The string version of the field name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
