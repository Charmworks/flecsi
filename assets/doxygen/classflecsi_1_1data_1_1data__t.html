<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>flecsi: flecsi::data::data_t&lt; user_meta_data_t, storage_policy_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="small-flecsi.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">flecsi
   &#160;<span id="projectnumber">0.0-1589-g850051e</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflecsi.html">flecsi</a></li><li class="navelem"><b>data</b></li><li class="navelem"><a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classflecsi_1_1data_1_1data__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">flecsi::data::data_t&lt; user_meta_data_t, storage_policy_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classflecsi_1_1data_1_1data__t.html" title="data_t provides an interface for registering and accessing data data. ">data_t</a> provides an interface for registering and accessing data data.  
 <a href="classflecsi_1_1data_1_1data__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="data_8h_source.html">data.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flecsi::data::data_t&lt; user_meta_data_t, storage_policy_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classflecsi_1_1data_1_1data__t.png" usemap="#flecsi::data::data_5Ft_3C_20user_5Fmeta_5Fdata_5Ft_2C_20storage_5Fpolicy_5Ft_20_3E_map" alt=""/>
  <map id="flecsi::data::data_5Ft_3C_20user_5Fmeta_5Fdata_5Ft_2C_20storage_5Fpolicy_5Ft_20_3E_map" name="flecsi::data::data_t&lt; user_meta_data_t, storage_policy_t &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad5c79f7189ee8535cd994e72711e15d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5c79f7189ee8535cd994e72711e15d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5c79f7189ee8535cd994e72711e15d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a> = typename sp_t::template <a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ad5c79f7189ee8535cd994e72711e15d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor type defined by the storage policy. <br /></td></tr>
<tr class="separator:ad5c79f7189ee8535cd994e72711e15d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ab5feb0d726f825400d56f55af699b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38ab5feb0d726f825400d56f55af699b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38ab5feb0d726f825400d56f55af699b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a> = typename sp_t::template <a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a38ab5feb0d726f825400d56f55af699b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor type defined by the storage policy. <br /></td></tr>
<tr class="separator:a38ab5feb0d726f825400d56f55af699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a049786f9159f5a13ed02f0c79f1020f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a049786f9159f5a13ed02f0c79f1020f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="separator:a049786f9159f5a13ed02f0c79f1020f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192443b71ab4b3f0e2749511436eecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4192443b71ab4b3f0e2749511436eecb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> (uintptr_t runtime_namespace)</td></tr>
<tr class="separator:a4192443b71ab4b3f0e2749511436eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64917dfc32e03fa45fff0821788e3f2b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a64917dfc32e03fa45fff0821788e3f2b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64917dfc32e03fa45fff0821788e3f2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>release</b> (T &amp;&amp;key, uintptr_t runtime_namespace)</td></tr>
<tr class="separator:a64917dfc32e03fa45fff0821788e3f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89bba5c1976c213eb6ccac12788e60b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89bba5c1976c213eb6ccac12788e60b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move</b> (uintptr_t from_runtime_namespace, uintptr_t to_runtime_namespace)</td></tr>
<tr class="separator:af89bba5c1976c213eb6ccac12788e60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd13d06b664fefe01908fd0bba5cf27a"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd13d06b664fefe01908fd0bba5cf27a"></a>
template&lt;typename A &gt; </td></tr>
<tr class="memitem:abd13d06b664fefe01908fd0bba5cf27a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save</b> (A &amp;archive) const </td></tr>
<tr class="separator:abd13d06b664fefe01908fd0bba5cf27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8b0fd11f3dd3a7f55822c83cff4f9d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e8b0fd11f3dd3a7f55822c83cff4f9d"></a>
template&lt;typename A &gt; </td></tr>
<tr class="memitem:a3e8b0fd11f3dd3a7f55822c83cff4f9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (A &amp;archive)</td></tr>
<tr class="separator:a3e8b0fd11f3dd3a7f55822c83cff4f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc79f92fe555520102b774635b7e727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedc79f92fe555520102b774635b7e727"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_</b> (uint64_t &amp;size) const </td></tr>
<tr class="separator:aedc79f92fe555520102b774635b7e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065e6b56abc494888d39d8374b9bd1a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a065e6b56abc494888d39d8374b9bd1a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unserialize_</b> (char *buf)</td></tr>
<tr class="separator:a065e6b56abc494888d39d8374b9bd1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1071ad65c6037dabb94ff8374656e35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1071ad65c6037dabb94ff8374656e35"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#ab1071ad65c6037dabb94ff8374656e35">data_t</a> ()</td></tr>
<tr class="memdesc:ab1071ad65c6037dabb94ff8374656e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ab1071ad65c6037dabb94ff8374656e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690d7959faa0cdd21b66dc1cc6a352e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a690d7959faa0cdd21b66dc1cc6a352e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a690d7959faa0cdd21b66dc1cc6a352e8">~data_t</a> ()</td></tr>
<tr class="memdesc:a690d7959faa0cdd21b66dc1cc6a352e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a690d7959faa0cdd21b66dc1cc6a352e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c5e2b96ad030e2a8d5315dea78a42e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91c5e2b96ad030e2a8d5315dea78a42e"></a>
template&lt;typename T , size_t NS, typename... Args&gt; </td></tr>
<tr class="memitem:a91c5e2b96ad030e2a8d5315dea78a42e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>register_data</b> (uintptr_t runtime_namespace, const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a91c5e2b96ad030e2a8d5315dea78a42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714325792db6f7f8251e13429c07c69d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0, typename... Args&gt; </td></tr>
<tr class="memitem:a714325792db6f7f8251e13429c07c69d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a714325792db6f7f8251e13429c07c69d">register_state</a> (const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, size_t indices, uintptr_t runtime_namespace, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a714325792db6f7f8251e13429c07c69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a state variable with the state manager. This method logically allocates space for the variable of size <em>indices</em> which will be identified by <em>key</em>.  <a href="#a714325792db6f7f8251e13429c07c69d">More...</a><br /></td></tr>
<tr class="separator:a714325792db6f7f8251e13429c07c69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d5237477dceff1a3bb0cf67313f49"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab61d5237477dceff1a3bb0cf67313f49"></a>
template&lt;size_t DT, typename T , size_t NS = 0, typename... Args&gt; </td></tr>
<tr class="memitem:ab61d5237477dceff1a3bb0cf67313f49"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>register_data</b> (uintptr_t runtime_namespace, const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ab61d5237477dceff1a3bb0cf67313f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a1556f2aebd6636e833761bd2b61dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58a1556f2aebd6636e833761bd2b61dd"></a>
template&lt;size_t DT, typename T , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a58a1556f2aebd6636e833761bd2b61dd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>access_data</b> (uintptr_t runtime_namespace, const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key)</td></tr>
<tr class="separator:a58a1556f2aebd6636e833761bd2b61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b313128aad1ea636d73151339dc8560"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b313128aad1ea636d73151339dc8560"></a>
template&lt;size_t NS = 0&gt; </td></tr>
<tr class="memitem:a6b313128aad1ea636d73151339dc8560"><td class="memTemplItemLeft" align="right" valign="top">user_meta_data_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>meta_data</b> (uintptr_t runtime_namespace, const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key)</td></tr>
<tr class="separator:a6b313128aad1ea636d73151339dc8560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda5ef6ca0a19849d734a2259bf691c2"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0&gt; </td></tr>
<tr class="memitem:abda5ef6ca0a19849d734a2259bf691c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#abda5ef6ca0a19849d734a2259bf691c2">dense_accessor</a> (const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, uintptr_t runtime_namespace=0)</td></tr>
<tr class="separator:abda5ef6ca0a19849d734a2259bf691c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44394a51fb29018f69f74324d28f38e5"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a44394a51fb29018f69f74324d28f38e5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a44394a51fb29018f69f74324d28f38e5">dense_accessors</a> (uintptr_t runtime_namespace=0)</td></tr>
<tr class="memdesc:a44394a51fb29018f69f74324d28f38e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em>.  <a href="#a44394a51fb29018f69f74324d28f38e5">More...</a><br /></td></tr>
<tr class="separator:a44394a51fb29018f69f74324d28f38e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ada4670decdd77d553b17273271d11"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a32ada4670decdd77d553b17273271d11"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a32ada4670decdd77d553b17273271d11">dense_accessors</a> (P &amp;&amp;predicate, uintptr_t runtime_namespace=0)</td></tr>
<tr class="memdesc:a32ada4670decdd77d553b17273271d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em> satisfying the predicate function <em>predicate</em>.  <a href="#a32ada4670decdd77d553b17273271d11">More...</a><br /></td></tr>
<tr class="separator:a32ada4670decdd77d553b17273271d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d30560130cc378fb632c13a2498f1ad"><td class="memTemplParams" colspan="2">template&lt;size_t NS = 0&gt; </td></tr>
<tr class="memitem:a4d30560130cc378fb632c13a2498f1ad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt; uint8_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a4d30560130cc378fb632c13a2498f1ad">raw_dense_accessors</a> (uintptr_t runtime_namespace=0)</td></tr>
<tr class="separator:a4d30560130cc378fb632c13a2498f1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393a470c4039a8fcfdb2a1135f62159"><td class="memTemplParams" colspan="2">template&lt;typename P , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a7393a470c4039a8fcfdb2a1135f62159"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt; uint8_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a7393a470c4039a8fcfdb2a1135f62159">raw_dense_accessors</a> (P &amp;&amp;predicate, uintptr_t runtime_namespace=0)</td></tr>
<tr class="separator:a7393a470c4039a8fcfdb2a1135f62159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d11c31812f090a01504ddae1b7be037"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0, typename... Args&gt; </td></tr>
<tr class="memitem:a1d11c31812f090a01504ddae1b7be037"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a1d11c31812f090a01504ddae1b7be037">register_global_state</a> (const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, uintptr_t runtime_namespace, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1d11c31812f090a01504ddae1b7be037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a state variable with the state manager. This method logically allocates space for the variable which will be identified by <em>key</em>.  <a href="#a1d11c31812f090a01504ddae1b7be037">More...</a><br /></td></tr>
<tr class="separator:a1d11c31812f090a01504ddae1b7be037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9f0aaad207135588e7358fae255685"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a2e9f0aaad207135588e7358fae255685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a2e9f0aaad207135588e7358fae255685">global_accessor</a> (const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, uintptr_t runtime_namespace=0)</td></tr>
<tr class="separator:a2e9f0aaad207135588e7358fae255685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cba03516730e4824cddb74af97ceeba"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a6cba03516730e4824cddb74af97ceeba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a6cba03516730e4824cddb74af97ceeba">global_accessors</a> (uintptr_t runtime_namespace=0)</td></tr>
<tr class="memdesc:a6cba03516730e4824cddb74af97ceeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em>.  <a href="#a6cba03516730e4824cddb74af97ceeba">More...</a><br /></td></tr>
<tr class="separator:a6cba03516730e4824cddb74af97ceeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4549c3d9b8f9a197f7ff20f7b20256dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a4549c3d9b8f9a197f7ff20f7b20256dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a4549c3d9b8f9a197f7ff20f7b20256dc">global_accessors</a> (P &amp;&amp;predicate, uintptr_t runtime_namespace=0)</td></tr>
<tr class="memdesc:a4549c3d9b8f9a197f7ff20f7b20256dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em> satisfying the predicate function <em>predicate</em>.  <a href="#a4549c3d9b8f9a197f7ff20f7b20256dc">More...</a><br /></td></tr>
<tr class="separator:a4549c3d9b8f9a197f7ff20f7b20256dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6231703c6d898c43c7913469e6d1f6c"><td class="memTemplParams" colspan="2">template&lt;size_t NS = 0&gt; </td></tr>
<tr class="memitem:ae6231703c6d898c43c7913469e6d1f6c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt; uint8_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#ae6231703c6d898c43c7913469e6d1f6c">raw_global_accessors</a> (uintptr_t runtime_namespace=0)</td></tr>
<tr class="separator:ae6231703c6d898c43c7913469e6d1f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f993dda1905bc2835796fb45d5f6546"><td class="memTemplParams" colspan="2">template&lt;typename P , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a7f993dda1905bc2835796fb45d5f6546"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt; uint8_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a7f993dda1905bc2835796fb45d5f6546">raw_global_accessors</a> (P &amp;&amp;predicate, uintptr_t runtime_namespace=0)</td></tr>
<tr class="separator:a7f993dda1905bc2835796fb45d5f6546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642005be3ed242b2d15c62f74afbcfc5"><td class="memTemplParams" colspan="2">template&lt;size_t NS = 0&gt; </td></tr>
<tr class="memitem:a642005be3ed242b2d15c62f74afbcfc5"><td class="memTemplItemLeft" align="right" valign="top">user_meta_data_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a642005be3ed242b2d15c62f74afbcfc5">meta_data</a> (const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, uintptr_t runtime_namespace=0)</td></tr>
<tr class="memdesc:a642005be3ed242b2d15c62f74afbcfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user meta data for the state variable identified by <em>key</em> in namespace <em>NS</em>.  <a href="#a642005be3ed242b2d15c62f74afbcfc5">More...</a><br /></td></tr>
<tr class="separator:a642005be3ed242b2d15c62f74afbcfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a7a9b8bed3274c14f0c6159f4b8af1"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t NS = 0&gt; </td></tr>
<tr class="memitem:a47a7a9b8bed3274c14f0c6159f4b8af1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a47a7a9b8bed3274c14f0c6159f4b8af1">data</a> (const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;key, uintptr_t runtime_namespace=0)</td></tr>
<tr class="memdesc:a47a7a9b8bed3274c14f0c6159f4b8af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the state variable as an array of type <em>T</em>.  <a href="#a47a7a9b8bed3274c14f0c6159f4b8af1">More...</a><br /></td></tr>
<tr class="separator:a47a7a9b8bed3274c14f0c6159f4b8af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e60ba2c098945a2ec2f5d1743c6677c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e60ba2c098945a2ec2f5d1743c6677c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a8e60ba2c098945a2ec2f5d1743c6677c">data_t</a> (const <a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;)=delete</td></tr>
<tr class="memdesc:a8e60ba2c098945a2ec2f5d1743c6677c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (disabled) <br /></td></tr>
<tr class="separator:a8e60ba2c098945a2ec2f5d1743c6677c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aa32a9f2bc24382d6d68b4dd88dd49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5aa32a9f2bc24382d6d68b4dd88dd49"></a>
<a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5aa32a9f2bc24382d6d68b4dd88dd49">operator=</a> (const <a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;)=delete</td></tr>
<tr class="memdesc:ad5aa32a9f2bc24382d6d68b4dd88dd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (disabled) <br /></td></tr>
<tr class="separator:ad5aa32a9f2bc24382d6d68b4dd88dd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267d20815ec814f8af26e996a76b5f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a267d20815ec814f8af26e996a76b5f75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data_t</b> (<a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a267d20815ec814f8af26e996a76b5f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6144d1ca04be0a41959557250a9e8d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6144d1ca04be0a41959557250a9e8d0"></a>
<a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae6144d1ca04be0a41959557250a9e8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aafb2b71c11950fddc104ad56e74a191a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1data_1_1data__t.html#aafb2b71c11950fddc104ad56e74a191a">instance</a> ()</td></tr>
<tr class="separator:aafb2b71c11950fddc104ad56e74a191a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename user_meta_data_t = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt;<br />
class flecsi::data::data_t&lt; user_meta_data_t, storage_policy_t &gt;</h3>

<p><a class="el" href="classflecsi_1_1data_1_1data__t.html" title="data_t provides an interface for registering and accessing data data. ">data_t</a> provides an interface for registering and accessing data data. </p>
<p>This type can be statically configured to use various implementations. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a47a7a9b8bed3274c14f0c6159f4b8af1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt;&amp; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the state variable as an array of type <em>T</em>. </p>
<dl class="section attention"><dt>Attention</dt><dd>Calls to this function are expensive because they require that data (that may not be physically stored as an array) be replicated and repackaged to satisfy this request.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to be used to interpret the state variable. </td></tr>
    <tr><td class="paramname">NS</td><td>The namespace of the desired state variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the state variable for which to return the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::shared_ptr&lt;T&gt; with a copy of the state data. </dd></dl>

</div>
</div>
<a class="anchor" id="abda5ef6ca0a19849d734a2259bf691c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt;T&gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::dense_accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a dense_accessor_t instance that provides logical array-based access to the state data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the variable to be returned. The type information for a state variable is not necessarily stored, meaning that the state can be interpreted however the user wants. Needless to say, if the type requested is not consistent with the actual stored type, bad things will happen. </td></tr>
    <tr><td class="paramname">NS</td><td>The namespace of the requested state variable. The default namespace is the <em>user</em> namespace as defined by flecsi::state_name_space_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the state variable to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An accessor to the requested state data. </dd></dl>

</div>
</div>
<a class="anchor" id="a44394a51fb29018f69f74324d28f38e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt;T&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::dense_accessors </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>All state variables of this type will be returned. </td></tr>
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of accessors to the state variables that match the type and namespace criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="a32ada4670decdd77d553b17273271d11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename P , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt;T&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::dense_accessors </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em> satisfying the predicate function <em>predicate</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>All state variables of this type will be returned. </td></tr>
    <tr><td class="paramname">P</td><td>Predicate function type. </td></tr>
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A predicate function (returns true or false) that will be used to select which state variables are included in the return vector. Valid predicate funcitons must match the signature: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> predicate(<span class="keyword">const</span> &amp; user_meta_data_t)</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of accessors to the state variables that match the namespace and predicate criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e9f0aaad207135588e7358fae255685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt;T&gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::global_accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a global_accessor_t instance that provides logical array-based access to the state data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the variable to be returned. The type information for a state variable is not necessarily stored, meaning that the state can be interpreted however the user wants. Needless to say, if the type requested is not consistent with the actual stored type, bad things will happen. </td></tr>
    <tr><td class="paramname">NS</td><td>The namespace of the requested state variable. The default namespace is the <em>user</em> namespace as defined by flecsi::state_name_space_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the state variable to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An accessor to the requested state data. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cba03516730e4824cddb74af97ceeba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt;T&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::global_accessors </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>All state variables of this type will be returned. </td></tr>
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of accessors to the state variables that match the type and namespace criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="a4549c3d9b8f9a197f7ff20f7b20256dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename P , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt;T&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::global_accessors </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a std::vector of accessors to the stored states with type <em>T</em> in namespace <em>NS</em> satisfying the predicate function <em>predicate</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>All state variables of this type will be returned. </td></tr>
    <tr><td class="paramname">P</td><td>Predicate function type. </td></tr>
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A predicate function (returns true or false) that will be used to select which state variables are included in the return vector. Valid predicate funcitons must match the signature: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> predicate(<span class="keyword">const</span> &amp; user_meta_data_t)</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of accessors to the state variables that match the namespace and predicate criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="aafb2b71c11950fddc104ad56e74a191a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classflecsi_1_1data_1_1data__t.html">data_t</a>&amp; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an instance of the data manager. </p>

</div>
</div>
<a class="anchor" id="a642005be3ed242b2d15c62f74afbcfc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">user_meta_data_t&amp; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::meta_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the user meta data for the state variable identified by <em>key</em> in namespace <em>NS</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the state variable for which to return the meta data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta data corresponding to the key and namespace. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d30560130cc378fb632c13a2498f1ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt;uint8_t&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::raw_dense_accessors </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a std::vector of raw accessors to the stored states with in namespace <em>NS</em>. Raw accessors are of type uint8_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of raw accessors to the state variables that match the namespace criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="a7393a470c4039a8fcfdb2a1135f62159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename P , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#ad5c79f7189ee8535cd994e72711e15d6">dense_accessor_t</a>&lt;uint8_t&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::raw_dense_accessors </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a std::vector of raw accessors to the stored states with in namespace <em>NS</em> satisfying the predicate function <em>predicate</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A predicate function (returns true or false) that will be used to select which state variables are included in the return vector. Valid predicate funcitons must match the signature: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> predicate(<span class="keyword">const</span> &amp; user_meta_data_t)</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of raw accessors to the state variables that match the namespace and predicate criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6231703c6d898c43c7913469e6d1f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt;uint8_t&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::raw_global_accessors </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a std::vector of raw accessors to the stored states with in namespace <em>NS</em>. Raw accessors are of type uint8_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of raw accessors to the state variables that match the namespace criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f993dda1905bc2835796fb45d5f6546"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename P , size_t NS = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflecsi_1_1data_1_1data__t.html#a38ab5feb0d726f825400d56f55af699b">global_accessor_t</a>&lt;uint8_t&gt; &gt; <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::raw_global_accessors </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a std::vector of raw accessors to the stored states with in namespace <em>NS</em> satisfying the predicate function <em>predicate</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NS</td><td>Namespace to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A predicate function (returns true or false) that will be used to select which state variables are included in the return vector. Valid predicate funcitons must match the signature: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> predicate(<span class="keyword">const</span> &amp; user_meta_data_t)</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of raw accessors to the state variables that match the namespace and predicate criteria. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d11c31812f090a01504ddae1b7be037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::register_global_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a state variable with the state manager. This method logically allocates space for the variable which will be identified by <em>key</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the variable to be registered. Any type that does not contain a pointer is supported. </td></tr>
    <tr><td class="paramname">NS</td><td>The namespace in which to register the state variable. The default namespace is the <em>user</em> namespace as defined by flecsi::state_name_space_t. Other namespaces may be defined to avoid naming collisions. </td></tr>
    <tr><td class="paramname">Args</td><td>A variadic list of arguments that are passed to the inititalization method of the user-defined meta data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the state variable to register. See the documentation for <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> for more information on valid usage. Normally, this parameter is just a <em>const</em> <em>char</em> <em>*</em>, e.g., "density". </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>A variadic list of arguments to pass to the initialization function of the user-defined meta data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FIXME </dd></dl>

</div>
</div>
<a class="anchor" id="a714325792db6f7f8251e13429c07c69d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename user_meta_data_t  = default_state_user_meta_data_t, template&lt; typename &gt; class storage_policy_t = default_data_storage_policy_t&gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t NS = 0, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classflecsi_1_1data_1_1data__t.html">flecsi::data::data_t</a>&lt; user_meta_data_t, storage_policy_t &gt;::register_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>runtime_namespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a state variable with the state manager. This method logically allocates space for the variable of size <em>indices</em> which will be identified by <em>key</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the variable to be registered. Any type that does not contain a pointer is supported. </td></tr>
    <tr><td class="paramname">NS</td><td>The namespace in which to register the state variable. The default namespace is the <em>user</em> namespace as defined by flecsi::state_name_space_t. Other namespaces may be defined to avoid naming collisions. </td></tr>
    <tr><td class="paramname">Args</td><td>A variadic list of arguments that are passed to the inititalization method of the user-defined meta data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the state variable to register. See the documentation for <a class="el" href="classflecsi_1_1const__string__t.html">const_string_t</a> for more information on valid usage. Normally, this parameter is just a <em>const</em> <em>char</em> <em>*</em>, e.g., "density". </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>The size of the index space with which this variable is associated, i.e., the number of elements to allocate. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>A variadic list of arguments to pass to the initialization function of the user-defined meta data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FIXME </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/flecsi/flecsi/flecsi/data/<a class="el" href="old__data_8h_source.html">old_data.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
