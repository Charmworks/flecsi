<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" type="image/x-icon" href="flecsi-favicon.ico" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Interface Documentation: Design Pattern: Object Factory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" height="200" style="margin-top:40px; margin-left:30px; margin-right:10px" src="medium-flecsi.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Interface Documentation<br>
		<span id="projectnumber">Version:</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design Pattern: Object Factory </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An object factory is a design pattern that allows a program to have multiple registered handlers for different types. As a motivating example, consider a program that must be able to read-in a variety of image formats: </p><div class="fragment"><div class="line">int main(int argc, char ** argv) {</div><div class="line"></div><div class="line">  std::string suffix = get_suffix(argv[1]);</div><div class="line"></div><div class="line">  base_io_handler_t * handler{nullptr};</div><div class="line"></div><div class="line">  if(suffix == &quot;gif&quot;) {</div><div class="line">    handler = new gif_io_handler_t(argv[1]);</div><div class="line">  }</div><div class="line">  else if(suffix == &quot;jpeg&quot;) {</div><div class="line">    handler = new jpeg_io_handler_t(argv[1]);</div><div class="line">  }</div><div class="line">  else if(suffix == &quot;png&quot;) {</div><div class="line">    handler = new png_io_handler_t(argv[1]);</div><div class="line">  } // if</div><div class="line"></div><div class="line">  handler-&gt;render();</div><div class="line"></div><div class="line">  return 0;</div><div class="line">} // main</div></div><!-- fragment --><p> This code is tedious to maintain for at least two reasons:</p>
<ul>
<li>It explicitly collects all of the types that can be handled by the program into a single logic block. This means that every time a new format is added, we must go back to this code and add a case for it.</li>
<li>The composing object must include all of the type information for the various handlers. This may not be desirable or possible in all cases, or may simply violate the project's design.</li>
</ul>
<p>A much better mechanism is to use an object factory: </p><div class="fragment"><div class="line">int main(int argc, char ** argv) {</div><div class="line"></div><div class="line">  base_io_handler_t * handler = factory_t::instance().create_handler(argv[0]);</div><div class="line"></div><div class="line">  handler-&gt;render();</div><div class="line"></div><div class="line">} // main</div></div><!-- fragment --><p>The code section below shows the factory type that makes this possible. There are three primary properties of the factory type that are important to this design pattern:</p>
<ol type="1">
<li>The factory is a singleton, and can be called from external scope to register the various handler types. In this example, we are using the Meyer's singleton discussed elsewhere in this document.</li>
<li>The factory exposes an interface to register a callback function for each suffix type. We will see how this can be called from each handler type's implementation to avoid having to collect all of the handlers together in one place.</li>
<li>The factory exposes a creation method that uses the filename's suffix to lookup the correct callback function to create a handler of the appropriate type.</li>
</ol>
<p>These are enumerated in the code comments in the following section: </p><div class="fragment"><div class="line">struct factory_t</div><div class="line">{</div><div class="line"></div><div class="line">  using callback_t =</div><div class="line">    std::function&lt;base_io_handler_t *(const std::string &amp;)&gt;;</div><div class="line"></div><div class="line">  // 1. Meyer&#39;s singleton instance method.</div><div class="line">  static</div><div class="line">  factory_t &amp;</div><div class="line">  instance()</div><div class="line">  {</div><div class="line">    static factory_t s;</div><div class="line">    return s;</div><div class="line">  } // instance</div><div class="line"></div><div class="line">  // 2. Callback registration method.</div><div class="line">  bool</div><div class="line">  register_handler(</div><div class="line">    const std::string suffix,</div><div class="line">    callback_t &amp; callback</div><div class="line">  )</div><div class="line">  {</div><div class="line">    if(registry_.find(suffix) == registry_.end()) {</div><div class="line">      registry_[suffix] = callback;</div><div class="line">    } // if</div><div class="line">  } // register_handler</div><div class="line"></div><div class="line">  // 3. Handler creation method.</div><div class="line">  base_io_handler_t *</div><div class="line">  create_handler(</div><div class="line">    const std::string &amp; filename</div><div class="line">  )</div><div class="line">  {</div><div class="line">    const std::string suffix = get_suffix(filename);</div><div class="line"></div><div class="line">    assert(registry_.find(suffix) != registry_.end());</div><div class="line"></div><div class="line">    return registry_[suffix](filename);</div><div class="line">  } // create_handler</div><div class="line"></div><div class="line">  factory_t(const factory_t &amp;) = delete;</div><div class="line">  factory_t &amp; operator = (const factory_t &amp;) = delete;</div><div class="line"></div><div class="line">private:</div><div class="line"></div><div class="line">  std::unordered_map&lt;std::string, callback_t&gt; registry_;</div><div class="line"></div><div class="line">  factory_t() {}</div><div class="line">  ~factory_t() {}</div><div class="line"></div><div class="line">}; // struct factory_t</div></div><!-- fragment --><p> Using the <em><a class="el" href="classfactory__t.html">factory_t</a></em> interface, we can register a particular handler like this: </p><div class="fragment"><div class="line">// 1. Define derived handler class (in this case for GIF images).</div><div class="line">struct gif_io_handler_t : public base_io_handler_t</div><div class="line">{</div><div class="line">  gif_io_handler_t(</div><div class="line">    const std::string &amp; filename</div><div class="line">  )</div><div class="line">  {</div><div class="line">    // Initialize handler and read GIF image.</div><div class="line">  } // gif_io_handler_t</div><div class="line"></div><div class="line">}; // struct gif_io_handler_t</div><div class="line"></div><div class="line">// 2. Define a function to create a new instance of gif_io_handler_t.</div><div class="line">base_io_handler_t *</div><div class="line">create_gif_io_handler(</div><div class="line">  const std::string &amp; filename</div><div class="line">)</div><div class="line">{</div><div class="line">  return new gif_io_handler_t(filename);</div><div class="line">} // create_gif_io_handler</div><div class="line"></div><div class="line">// 3. Register the handler callback function with the object factory.</div><div class="line">bool gif_io_handler_registered =</div><div class="line">  factory_t::instance().register_handler(&quot;gif&quot;, create_gif_io_handler);</div></div><!-- fragment --><p> Notice that the logic used to register a new handler can be called from within the file that defines it. This is extremely useful in maintaining code because there is no single place where all of the handlers must be known. The factory keeps track of this for us with its <em>registry_</em> map. Now, if the developer wants to add a new type, they must only define the type, deriving from the base <em>base_io_handler_t</em> type, and register it. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
